'use strict';

(function () {
    'use strict';

    // more stringent uri encoding (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent)
    // for some reason api gateway will give a nasty error if query params contain !'()*

    (function () {
        var standardEncodeURIComponent = encodeURIComponent;
        encodeURIComponent = function encodeURIComponent(string) {
            return standardEncodeURIComponent(string).replace(/[!'()*]/g, function (c) {
                return '%' + c.charCodeAt(0).toString(16).toUpperCase();
            });
        };
    })();

    angular.module('ftap', ['ionic', 'ui.validate', 'ngLodash', 'ngCordova', 'angularMoment', 'ngclamp-js']).config(function ($ionicConfigProvider) {
        $ionicConfigProvider.tabs.position('bottom');
        $ionicConfigProvider.tabs.style('standard');
        $ionicConfigProvider.navBar.alignTitle('center');
        $ionicConfigProvider.views.maxCache(0);
    }).run(function (FTAP_CONFIG) {
        var firstScriptTag = document.getElementsByTagName('script')[0],
            tag = document.createElement('script');

        tag.src = 'https://maps.googleapis.com/maps/api/js?key=' + FTAP_CONFIG.GOOGLE_API_KEY + '&libraries=places';
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }).run(function ($ionicPlatform, $cordovaKeyboard) {
        $ionicPlatform.ready(function () {
            $cordovaKeyboard.hideAccessoryBar(true);
            $cordovaKeyboard.disableScroll(true);
        });
    }).run(function ($rootScope, $window, $state) {
        $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams, options) {
            if (angular.isDefined($window.NativeTap) && fromState && fromState.native) {
                NativeTap.hide();
            }
        });
    }).run(function (PushNotificationService) {
        PushNotificationService.checkIfEnabled().then(PushNotificationService.register);
    }).run(function ($ionicPlatform, LocationService) {
        if (localStorage.ONBOARDING_COMPLETE) {
            LocationService.startUp();
            $ionicPlatform.on('resume', LocationService.startUp);
        }
    }).run(function ($ionicPlatform, AnalyticsService) {
        AnalyticsService.recordStart();

        $ionicPlatform.on('resume', AnalyticsService.recordResume);
    });
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').constant('FTAP_CONFIG', {
        GOOGLE_API_KEY: 'AIzaSyCOjTbUQRFmPCS8lfn7l5P4hEkzRaHUljo',
        IDENTITY_POOL_ID: 'us-east-1:8549c2e6-4011-47e7-9f9c-98b9a7fcd574',
        AWS_REGION: 'us-east-1',
        USER_POOL_ID: 'us-east-1_pevdYd9Q7',
        USER_POOL_ARN: 'arn:aws:cognito-idp:us-east-1:825507249025:userpool/us-east-1_pevdYd9Q7',
        USER_POOL_CLIENT_ID: '103plmca07k3dqqdrnia7ri68r',
        S3_PHOTO_BUCKET: 'mobforrester-tap-photos-dev',
        S3_RESOURCE_BUCKET: 'mobforrester-app-resources-dev',
        GCM_SENDER_ID: '904968220582',
        MOBILE_ANALYTICS_APP_ID: 'a051ab718de24f7a8fe29e7c4989901a',
        A_OR_B: 'a',
        VERSION_NUMBER: '1.0.',
        SHOW_DEBUG_INFO: 'true' === 'true'
    });
})();
'use strict';

(function () {
    'use strict';

    // adapted from http://stackoverflow.com/questions/17547917/angularjs-image-onload-event

    angular.module('ftap').directive('onLoad', onLoad);

    onLoad.$inject = ['$parse'];

    function onLoad($parse) {
        return {
            restrict: 'A',
            link: function link(scope, element, attrs) {
                var fn = $parse(attrs.onLoad);

                element.on('load', function (event) {
                    scope.$apply(function () {
                        fn(scope, { $event: event });
                    });
                });
            }
        };
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').directive('setMapHeight', function ($window, PlatformService) {
        return function (scope, element, attrs) {
            if (PlatformService.isIOS()) {
                /**
                 * header height: 64px
                 * nearby subheader: 55px
                 * bottom tab bar height: 49px
                 * total deduction: 168px
                 */
                element.css('height', $window.innerHeight - 168 + 'px');
            }

            if (PlatformService.isAndroid()) {
                /**
                 * header height: 44px
                 * nearby subheader: 55px
                 * bottom tab bar height: 49px
                 * total deduction: 148px
                 */
                element.css('height', $window.innerHeight - 148 + 'px');
            }
        };
    });
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').filter('abs', abs);

    abs.$inject = [];

    function abs() {
        return function (input) {
            return Math.abs(input);
        };
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').filter('ioisByRating', ioisByRating);

    ioisByRating.$inject = [];

    function ioisByRating() {
        return function (items, rating) {
            var filtered = [];

            if (angular.isArray(items)) {
                items.forEach(function (item) {
                    if (item.hasOwnProperty(rating + 'Count') && item[rating + 'Count'] > 0) {
                        item.count = item[rating + 'Count'];
                        item.change = item[rating + 'Change'];
                        filtered.push(item);
                    }
                });
            }

            return filtered;
        };
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').filter('mob', mob);

    mob.$inject = [];

    function mob() {
        return function (items, isActive) {
            return isActive ? items.filter(function (item) {
                return item.isMob;
            }) : items;
        };
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').filter('rating', rating);

    rating.$inject = [];

    function rating() {
        /**
         * `options` will look like { love: true, ok: true, hate: false }
         */
        return function (items, options) {
            return options ? items.filter(function (item) {
                return Object.keys(options).filter(function (key) {
                    return options[key];
                }).indexOf(item.rating) !== -1;
            }) : items;
        };
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').filter('shortNumber', shortNumber);

    shortNumber.$inject = ['$window', '$filter'];

    function shortNumber($window, $filter) {
        return function (input) {
            return input >= 10000 ? $window.shortNumber(input) : $filter('number')(input);
        };
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').filter('underscoreToSpace', underscoreToSpace);

    underscoreToSpace.$inject = [];

    function underscoreToSpace() {
        return function (input) {
            input = input + ''; // cast to string
            return input.replace(/_/g, ' ');
        };
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').config(routes);

    routes.$inject = ['$stateProvider', '$urlRouterProvider', 'FTAP_CONFIG'];

    /**
     * Resolve routes to check whether the user is logged in. This also
     * reauthenticates the user (if possible) to allow them to use any route
     *
     * Users are kicked out of auth routes if they are logged in and kicked
     * out of main routes if they are logged out
     */
    var reauthResolver = {
        isLoggedInFacebook: ['$ionicPlatform', 'AuthService', 'FacebookService', 'UserService', function ($ionicPlatform, AuthService, FacebookService, UserService) {
            return $ionicPlatform.ready().then(function () {
                return FacebookService.hasPlugin() ? AuthService.checkFacebookLoginStatus().then(function () {
                    return true;
                }).catch(function () {
                    return false;
                }) : false;
            });
        }],
        isAnonymous: ['AuthService', 'UserService', 'isLoggedInFacebook', function (AuthService, UserService, isLoggedInFacebook) {
            return isLoggedInFacebook ? false : AuthService.anonymousLogin().then(function () {
                return true;
            }).catch(function () {
                return false;
            });
        }]
    };

    function routes($stateProvider, $urlRouterProvider, FTAP_CONFIG) {
        var USE_CONFIG_A = FTAP_CONFIG.A_OR_B !== 'b';

        $stateProvider
        // onboarding
        .state('onboarding', {
            url: '/onboarding',
            templateUrl: 'app/routes/onboarding/onboarding.html',
            controller: 'OnboardingController',
            controllerAs: 'onboardCtrl'
        })

        // login parent state
        .state('auth', {
            url: '/auth',
            abstract: true,
            params: {
                reload: null
            },
            templateUrl: 'app/routes/auth/auth.html',
            controller: 'AuthController',
            controllerAs: 'authCtrl',
            resolve: reauthResolver
        })

        // signup
        .state('auth.signup', {
            url: '/signup',
            templateUrl: 'app/routes/auth/signup/signup.html',
            controller: 'SignupController',
            controllerAs: 'signupCtrl'
        })

        // signup success
        .state('auth.signup-success', {
            url: '/success',
            params: { hasFacebook: null },
            cache: false,
            templateUrl: 'app/routes/auth/signup-success/signup-success.html',
            controller: 'SignupSuccessController',
            controllerAs: 'successCtrl'
        })

        // login
        .state('auth.login', {
            url: '/login',
            templateUrl: 'app/routes/auth/login/login.html',
            controller: 'LoginController',
            controllerAs: 'loginCtrl'
        })

        // main parent state
        .state('main', {
            url: '/main',
            abstract: true,
            templateUrl: 'app/routes/main/main.html',
            controller: 'MainController',
            controllerAs: 'mainCtrl',
            resolve: reauthResolver
        })

        // tap
        .state('main.tap', {
            url: '/tap',
            views: {
                'main-tap': {
                    templateUrl: 'app/routes/main/tap/tap.html',
                    controller: 'TapController',
                    controllerAs: 'tapCtrl'
                }
            },
            native: true,
            resolve: {
                native: ['$q', '$ionicPlatform', '$timeout', '$window', 'TapParamsService', function ($q, $ionicPlatform, $timeout, $window, TapParamsService) {
                    var deferred = $q.defer();
                    $ionicPlatform.ready(function () {
                        if (angular.isDefined($window.NativeTap) && !TapParamsService.hasParams()) {
                            NativeTap.show(function () {
                                deferred.resolve();
                            }, null, { reInitialize: false, showCoachMarks: !localStorage.COACH_MARKS_SEEN });
                        } else {
                            $timeout(function () {
                                deferred.resolve();
                            });
                        }
                    });

                    return deferred.promise;
                }]
            }
        })

        // nearby
        .state('main.nearby', {
            url: '/nearby',
            abstract: true,
            views: {
                'main-nearby': {
                    templateUrl: 'app/routes/main/nearby/nearby.html',
                    controller: 'NearbyController',
                    controllerAs: 'nearbyCtrl'
                }
            }
        })

        // mobs
        .state('main.mobs', {
            url: '/mobs',
            views: {
                'main-mobs': {
                    templateUrl: 'app/routes/main/mobs/mobs.html',
                    controller: 'MobsController',
                    controllerAs: 'mobsCtrl'
                }
            }
        })

        // feed
        .state('main.feed', {
            url: '/feed',
            params: { tapCreated: null },
            views: {
                'main-feed': {
                    templateUrl: 'app/routes/main/feed/feed.html',
                    controller: 'FeedController',
                    controllerAs: 'feedCtrl'
                }
            }
        })

        // profile
        .state('main.profile', {
            url: '/profile',
            abstract: true,
            views: {
                'main-profile': {
                    templateUrl: 'app/routes/main/profile/profile.html',
                    controller: 'ProfileController',
                    controllerAs: 'profileCtrl'
                }
            }
        });

        var nearbySubstates = [{
            name: 'main.nearby.map',
            config: {
                url: '/map',
                templateUrl: 'app/routes/main/nearby/nearby-map/nearby-map.html',
                controller: 'NearbyMapController',
                controllerAs: 'mapCtrl'
            }
        }, {
            name: 'main.nearby.list',
            config: {
                url: '/list',
                templateUrl: 'app/routes/main/nearby/nearby-list/nearby-list.html',
                controller: 'NearbyListController',
                controllerAs: 'listCtrl'
            }
        }];

        var profileSubstates = [{
            name: 'main.profile.my-mobs',
            config: {
                url: '/my-mobs',
                templateUrl: 'app/routes/main/profile/my-mobs/my-mobs.html',
                controller: 'MyMobsController',
                controllerAs: 'mobsCtrl'
            }
        }, {
            name: 'main.profile.settings',
            config: {
                url: '/settings',
                templateUrl: 'app/routes/main/profile/settings/settings.html',
                controller: 'SettingsController',
                controllerAs: 'settingsCtrl'
            }
        }];

        var substatesList = [{
            url: '/main/nearby',
            states: nearbySubstates
        }, {
            url: '/main/profile',
            states: profileSubstates
        }];

        // Apply state definitions for all substates. Substate definitions are
        // used below to set the default substate based on previous selection
        // with sub tabs
        substatesList.forEach(function (substateDefinitionList) {
            // When hitting the abstract state, transition to the last `active`
            // substate. If none, transition to the first substate in the list
            var substateDefinitions = substateDefinitionList.states;
            $urlRouterProvider.when(substateDefinitionList.url, function ($state) {
                var substates = substateDefinitions.map(function (state) {
                    return $state.get(state.name);
                });
                $state.transitionTo(substates.find(function (state) {
                    return state.active;
                }) || substates[0], {});
            });

            // For each group of substates...
            substateDefinitions.forEach(function (substateDefinition) {
                // Create the substate for the router
                // Set the substate as `active` when the state is entered. All
                // other substates in this group should be marked inactive
                substateDefinition.config.onEnter = function ($state) {
                    substateDefinitions.forEach(function (stateDefinition) {
                        return $state.get(stateDefinition.name).active = false;
                    });
                    $state.get(substateDefinition.name).active = true;
                };

                // Create the state
                $stateProvider.state(substateDefinition.name, substateDefinition.config);
            });
        });

        // if none of the above states are matched, use this as the fallback
        $urlRouterProvider.otherwise('/auth/signup');
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('AnalyticsService', AnalyticsService);

    AnalyticsService.$inject = ['$injector', 'FTAP_CONFIG', 'AuthService', 'UserService', 'SharingService'];

    // AWS config credentials are set when AuthService is instantiated
    function AnalyticsService($injector, FTAP_CONFIG, AuthService, UserService, SharingService) {
        var service = {
            client: new AMA.Manager({
                appId: FTAP_CONFIG.MOBILE_ANALYTICS_APP_ID
            })
        };

        var APP_NAME = 'Forrester TAP';

        service.recordStart = function () {
            service.client.recordEvent('appStart');
        };

        service.recordResume = function () {
            service.client.recordEvent('appResume');
        };

        service.recordTap = function (duration) {
            service.client.recordEvent('tapSubmitted', {}, { duration: duration });
        };

        /**
         * screenNames:
         * <Splash, FB Signup, Email Signup, Success, FB Login, Email Login,
         *  Main TAP, Love TAP, OK TAP, Hate TAP, Love Location, Location Details,
         *  Map View, Map Filter, Map Detail, MOBs View, MOBs Filter, My Feed, Post,
         *  MOBs, Settings>
         */

        service.recordEvent = function (eventType, screenName, attributes, metrics) {
            var LocationService = $injector.get('LocationService');
            var locationMetrics = LocationService.hasLocation ? {
                profile_location_enabled: 1,
                session_location_lat: LocationService.lastKnownLocation.coords.latitude,
                session_location_lon: LocationService.lastKnownLocation.coords.longitude
            } : {
                profile_location_enabled: 0
            };

            var sharing = SharingService.facebook ? 1 : 0;

            service.client.recordEvent(eventType, angular.extend({
                "profile_signupDate": UserService.timestamp || "N/A",
                "profile_gender": UserService.gender || "N/A",
                "profile_city": UserService.city || "N/A",
                "profile_birthYear": UserService.birthYear || "N/A",
                "ctx_screenName": screenName,
                "ctx_appName": APP_NAME
            }, attributes || {}), angular.extend(locationMetrics, {
                "profile_LOVEs": UserService.loveCount,
                "profile_OKs": UserService.okCount,
                "profile_HATEs": UserService.hateCount,
                "profile_shareFB": sharing,
                "profile_notifications_enabled": UserService.notifs
            }, metrics || {}));
        };

        service.screenView = function (screenName) {
            service.recordEvent('SCREENVIEW', screenName);
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('ApiService', ApiService);

    ApiService.$inject = ['$q', '$injector'];

    function ApiService($q, $injector) {
        var service = {};

        service.request = function (verb, params, body, additionalParams) {
            return $q(function (resolve, reject) {
                if (AWS.config.credentials.needsRefresh()) {
                    // the below method of credential refreshing should only work for unauthenticated users

                    AWS.config.credentials.refresh(function (err) {
                        if (err) {
                            return reject(err);
                        }

                        service.request(verb, params, body, additionalParams).then(resolve).catch(reject);
                    });

                    // below is for facebook/email auth

                    /* const AuthService = $injector.get('AuthService');
                     if (AuthService.isUsingFacebook()) {
                        AuthService.checkFacebookLoginStatus()
                        .then(result =>
                            service.request(verb, params, body, additionalParams).then(resolve).catch(reject)
                        )
                        .catch(reject);
                    } else {
                        AuthService.checkEmailLoginStatus()
                        .then(result =>
                            service.request(verb, params, body, additionalParams).then(resolve).catch(reject)
                        )
                        .catch(reject);
                    } */
                } else {
                    var apigClient = apigClientFactory.newClient({
                        accessKey: AWS.config.credentials.accessKeyId,
                        secretKey: AWS.config.credentials.secretAccessKey,
                        sessionToken: AWS.config.credentials.sessionToken
                    });

                    if (angular.isDefined(apigClient[verb])) {
                        apigClient[verb](params, body, additionalParams).then(resolve).catch(reject);
                    } else {
                        reject("Verb not defined in API Gateway");
                    }
                }
            });
        };

        return service;
    }
})();
'use strict';

/*global AWS AWSCognito*/
(function () {
    'use strict';

    angular.module('ftap').factory('AuthService', AuthService);

    AuthService.$inject = ['$window', '$q', 'FTAP_CONFIG', 'FacebookService', 'ApiService', 'UserService', 'ProfilePictureService'];

    function AuthService($window, $q, FTAP_CONFIG, FacebookService, ApiService, UserService, ProfilePictureService) {
        AWS.config.region = FTAP_CONFIG.AWS_REGION;
        AWS.config.logger = console;
        initializeAWSCredentials();

        AWSCognito.config.region = FTAP_CONFIG.AWS_REGION;
        AWSCognito.config.credentials = new AWS.CognitoIdentityCredentials({
            IdentityPoolId: FTAP_CONFIG.IDENTITY_POOL_ID,
            RoleArn: FTAP_CONFIG.USER_POOL_ARN
        });

        // dummy data, necessary for user pools that don't allow unauthenticated access
        AWSCognito.config.update({
            accessKeyId: 'anything',
            secretAccessKey: 'anything'
        });

        var poolData = {
            UserPoolId: FTAP_CONFIG.USER_POOL_ID,
            ClientId: FTAP_CONFIG.USER_POOL_CLIENT_ID,
            Paranoia: 7
        };

        var userPool = new AWSCognito.CognitoIdentityServiceProvider.CognitoUserPool(poolData);

        var service = {
            anonymousLogin: anonymousLogin,
            emailSignup: emailSignup,
            emailLogin: emailLogin,
            facebookAuth: facebookAuth,
            facebookLink: facebookLink,
            facebookUnlink: facebookUnlink,
            checkFacebookLoginStatus: checkFacebookLoginStatus,
            checkEmailLoginStatus: checkEmailLoginStatus,
            logOut: logOut,
            isUsingFacebook: isUsingFacebook,
            isUsingEmail: isUsingEmail
        };

        return service;

        ///

        function anonymousLogin() {
            return $q(function (resolve, reject) {
                initializeAWSCredentials();

                AWS.config.credentials.get(function (err) {
                    if (err) {
                        reject(err);
                    } else {
                        UserService.registerUser(null, null, null, null);
                        resolve();
                    }
                });
            });
        }

        function emailSignup(name, email, username, password) {
            var deferred = $q.defer();

            userPool.signUp(username, password, [new AWSCognito.CognitoIdentityServiceProvider.CognitoUserAttribute({
                Name: 'name',
                Value: name
            }), new AWSCognito.CognitoIdentityServiceProvider.CognitoUserAttribute({
                Name: 'email',
                Value: email
            }), new AWSCognito.CognitoIdentityServiceProvider.CognitoUserAttribute({
                Name: 'preferred_username',
                Value: username
            })], null, function (err, result) {
                if (err) {
                    deferred.reject(err);
                }

                UserService.username = username;
                UserService.email = email;

                deferred.resolve(result);
            });

            return deferred.promise.then(function () {
                return emailLogin(username, password, true);
            }).then(function () {
                return UserService.registerUser(null, email, null, username);
            });
        }

        function emailLogin(username, password, skipRegister) {
            var deferred = $q.defer();
            var cognitoUser = new AWSCognito.CognitoIdentityServiceProvider.CognitoUser({
                Username: username,
                Pool: userPool
            });

            cognitoUser.authenticateUser(new AWSCognito.CognitoIdentityServiceProvider.AuthenticationDetails({
                Username: username,
                Password: password
            }), {
                onSuccess: function onSuccess(result) {
                    UserService.username = username;

                    AWS.config.credentials.params.Logins = {};
                    AWS.config.credentials.params.Logins['cognito-idp.' + FTAP_CONFIG.AWS_REGION + '.amazonaws.com/' + FTAP_CONFIG.USER_POOL_ID] = result.idToken.jwtToken;
                    AWS.config.credentials.expired = true;

                    AWS.config.credentials.get(function (err) {
                        // TODO this should probably be handled in one spot
                        // with the actual response
                        UserService.cogId = AWS.config.credentials.identityId;
                        if (err) {
                            cognitoUser.signOut();
                            deferred.reject(err);
                        } else {
                            deferred.resolve();
                        }
                    });
                },

                onFailure: function onFailure(err) {
                    return deferred.reject(err);
                }
            });

            return skipRegister ? deferred.promise : deferred.promise.then(function () {
                return UserService.registerUser(null, null, null, username);
            }).then(function (response) {
                if (response.data.socialid) {
                    return $q(function (resolve, reject) {
                        return checkFacebookLoginStatus().then(resolve).catch(function () {
                            return facebookAuth().then(resolve).catch(reject);
                        });
                    });
                } else {
                    return response;
                }
            });
        };

        function facebookAuth() {
            return facebookLogin().then(function () {
                return FacebookService.getMyInfo();
            }).then(function (info) {
                UserService.birthYear = info.birthday.split("/")[2];
                UserService.city = info.location.name.split(",")[0];
                UserService.email = info.email;
                UserService.gender = info.gender;
                UserService.location = info.location.name;
                UserService.name = info.name;
                UserService.socialId = info.id;

                return UserService.registerUser(info.id, info.email, ProfilePictureService.getFacebookProfilePictureUrl(), info.username);
            });
        };

        function facebookLink() {
            return facebookLogin().then(function () {
                return FacebookService.getMyInfo();
            }).then(function (info) {
                UserService.birthYear = info.birthday.split("/")[2];
                UserService.city = info.location.name.split(",")[0];
                UserService.email = info.email;
                UserService.gender = info.gender;
                UserService.location = info.location.name;
                UserService.name = info.name;
                UserService.socialId = info.id;

                return UserService.updateSocialId(ProfilePictureService.getFacebookProfilePictureUrl());
            }).catch(function (err) {
                // clear out facebook info if link failed
                UserService.birthYear = null;
                UserService.city = null;
                UserService.email = null;
                UserService.gender = null;
                UserService.location = null;
                UserService.name = null;
                UserService.socialId = null;
                UserService.timestamp = null;

                return $q.reject(err);
            });
        }

        function facebookUnlink() {
            return $q(function (resolve) {
                return facebookConnectPlugin.logout(resolve, resolve);
            }).then(function () {
                return $q(function (resolve, reject) {
                    var cognitoidentity = new AWS.CognitoIdentity();

                    // NOTE: Doing this unlink disables the current Cognito identityId, so a new one is generated.
                    // Essentially, this means that the user is starting a new anonymous account. This is a feature of
                    // Cognito, not a bug; it's a security risk to have an account go from unauthenticated access to
                    // authenticated access only and then back to unauthenticated access.
                    cognitoidentity.unlinkIdentity({
                        IdentityId: AWS.config.credentials.identityId,
                        Logins: AWS.config.credentials.params.Logins,
                        LoginsToRemove: ['graph.facebook.com']
                    }, function (err, data) {
                        return err ? reject(err) : resolve(data);
                    });
                });
            }).then(function () {
                UserService.birthYear = null;
                UserService.city = null;
                UserService.email = null;
                UserService.gender = null;
                UserService.location = null;
                UserService.name = null;
                UserService.socialId = null;
                UserService.timestamp = null;

                delete AWS.config.credentials.params.Logins['graph.facebook.com'];
            });
        }

        function facebookLogin() {
            return $q(function (resolve, reject) {
                facebookConnectPlugin.logout(doLogin, doLogin); // make sure the user is actually logged out before attempting login
                // (otherwise, an error will be thrown)
                function doLogin() {
                    facebookConnectPlugin.login(['public_profile', 'user_friends', 'email'], function (result) {
                        AWS.config.credentials.params.Logins = AWS.config.credentials.params.Logins || {};
                        AWS.config.credentials.params.Logins['graph.facebook.com'] = result.authResponse.accessToken;
                        AWS.config.credentials.expired = true;

                        AWS.config.credentials.get(function (err) {
                            if (err) {
                                reject(err);
                            } else {
                                resolve();
                            }
                        });

                        // Native Tap should display Facebook sharing slider
                        if ($window.NativeTap) {
                            NativeTap.setProfileSettings({
                                isLoggedInFacebook: true
                            });
                        }
                    }, reject);
                }
            });
        }

        function checkFacebookLoginStatus() {
            return $q(function (resolve, reject) {
                return FacebookService.checkLoginStatus().then(function (result) {
                    if (result.authResponse) {
                        AWS.config.credentials.params.Logins = {
                            'graph.facebook.com': result.authResponse.accessToken
                        };
                        AWS.config.credentials.expired = true;

                        AWS.config.credentials.get(function (err) {
                            if (err) {
                                reject(err);
                            } else {
                                resolve();
                            }
                        });
                    } else {
                        reject(result);
                    }
                }).catch(reject);
            }).then(function () {
                return FacebookService.getMyInfo();
            }).then(function (info) {
                UserService.birthYear = info.birthday.split("/")[2];
                UserService.city = info.location.name.split(",")[0];
                UserService.email = info.email;
                UserService.gender = info.gender;
                UserService.location = info.location.name;
                UserService.name = info.name;
                UserService.socialId = info.id;

                return UserService.registerUser(info.id, info.email, ProfilePictureService.getFacebookProfilePictureUrl(), info.username);
            });
        }

        function checkEmailLoginStatus() {
            return $q(function (resolve, reject) {
                var cognitoUser = userPool.getCurrentUser();

                if (cognitoUser != null) {
                    cognitoUser.getSession(function (err, session) {
                        if (err) {
                            cognitoUser.signOut();
                            return reject(err);
                        }

                        AWS.config.credentials.params.Logins = {};
                        AWS.config.credentials.params.Logins['cognito-idp.' + FTAP_CONFIG.AWS_REGION + '.amazonaws.com/' + FTAP_CONFIG.USER_POOL_ID] = session.idToken.jwtToken;
                        AWS.config.credentials.expired = true;

                        AWS.config.credentials.get(function (err) {
                            if (err) {
                                cognitoUser.signOut();
                                return reject(err);
                            }

                            return resolve(cognitoUser.getUsername());
                        });
                    });
                } else {
                    reject();
                }
            }).then(function (username) {
                UserService.username = username;
                return UserService.registerUser(null, null, null, username);
            });
        }

        function logOut() {
            return $q(function (resolve, reject) {
                if (service.isUsingEmail()) {
                    userPool.getCurrentUser().signOut();
                }

                if (service.isUsingFacebook()) {
                    facebookConnectPlugin.logout(function () {
                        initializeAWSCredentials();
                        resolve();

                        // Native Tap should not display Facebook sharing slider
                        if ($window.NativeTap) {
                            NativeTap.setProfileSettings({
                                isLoggedInFacebook: false
                            });
                        }
                    }, reject);
                } else {
                    initializeAWSCredentials();
                    resolve();
                }
            });
        }

        function isUsingFacebook() {
            return AWS.config.credentials && AWS.config.credentials.params && AWS.config.credentials.params.Logins && AWS.config.credentials.params.Logins['graph.facebook.com'];
        }

        function isUsingEmail() {
            return AWS.config.credentials && AWS.config.credentials.params && AWS.config.credentials.params.Logins && AWS.config.credentials.params.Logins['cognito-idp.' + FTAP_CONFIG.AWS_REGION + '.amazonaws.com/' + FTAP_CONFIG.USER_POOL_ID];
        }

        function initializeAWSCredentials() {
            AWS.config.credentials = new AWS.CognitoIdentityCredentials({
                IdentityPoolId: FTAP_CONFIG.IDENTITY_POOL_ID
            });
            // the line below is needed for the current facebook/user pools auth implementation, but not cognito unauth
            // AWS.config.credentials.clearCachedId();
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('CameraService', CameraService);

    CameraService.$inject = ['$q', '$window'];

    function CameraService($q, $window) {
        var service = {};

        service.getPicture = function () {
            return $q(function (resolve, reject) {
                return $window.navigator.camera.getPicture(resolve, reject, {
                    quality: 30,
                    destinationType: $window.Camera.DestinationType.FILE_URI,
                    correctOrientation: true
                });
            });
        };

        service.cleanup = function () {
            return $q(function (resolve, reject) {
                return $window.navigator.camera.cleanup(resolve, reject);
            });
        };

        service.crop = function (imageUri, width, height, returnBlob) {
            return $q(function (resolve, reject) {
                try {
                    (function () {
                        var image = document.createElement('img');
                        var canvas = document.createElement('canvas');
                        var context = canvas.getContext('2d');

                        canvas.width = width;
                        canvas.height = height;

                        image.src = imageUri;
                        image.onload = function () {
                            var scale = Math.max(canvas.width / image.width, canvas.height / image.height);
                            context.drawImage(image, (canvas.width - image.width * scale) / 2, (canvas.height - image.height * scale) / 2, image.width * scale, image.height * scale);

                            if (returnBlob) {
                                canvas.toBlob(resolve, 'image/png');
                            } else {
                                resolve(canvas.toDataURL('image/png'));
                            }
                        };
                    })();
                } catch (e) {
                    reject(e);
                }
            });
        };

        return service;
    }
})();
'use strict';

/**
 * Fetch and assign sample responses from API
 */
(function () {
    'use strict';

    angular.module('ftap').factory('CannedResponseService', CannedResponseService);

    CannedResponseService.$inject = ['$http', '$q', '$filter', 'FTAP_CONFIG', 'ApiService'];

    function CannedResponseService($http, $q, $filter, FTAP_CONFIG, ApiService) {
        var service = {};

        service.defaultResponses = { // fallback
            'love': ['One of my favorites', 'Absolutely fantastic!', 'Highly recommended', 'Better than the others'],

            'ok': ['Just alright', 'Neither good nor bad', 'Not the greatest', 'Could take it or leave it'],

            'hate': ['Terrible, just terrible', 'Avoid if you can', 'Would not recommend at all', 'No thanks']
        };

        service.getResponses = function (ioiId, rating) {
            if (Object.keys(service.defaultResponses).indexOf(rating) === -1) {
                return $q.reject('Please provide a valid rating ("love"/"ok"/"hate")');
            }

            var queryParams = { ioiId: ioiId, rating: rating };

            return ApiService.request('observationOtherResponsesGet', queryParams, {}, { queryParams: queryParams }).then(function (response) {
                return response.data.data;
            }).catch(function (err) {
                return service.defaultResponses[rating].map(function (phrase) {
                    return { phrase: phrase, count: 0 };
                });
            }).then(function (responses) {
                return responses.map(function (response) {
                    return {
                        phrase: response.phrase,
                        count: response.count,
                        formattedCount: $filter('shortNumber')(response.count),
                        formattedCountPlusOne: $filter('shortNumber')(response.count + 1),
                        isMob: !!response.isMob,
                        mobId: response.mobId || '',
                        isMobMember: !!response.isMobMember
                    };
                });
            });
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('FacebookService', FacebookService);

    FacebookService.$inject = ['$q', '$window', 'ApiService', 'UserService'];

    function FacebookService($q, $window, ApiService, UserService) {
        var service = {};

        service.hasPlugin = function () {
            return angular.isDefined($window.facebookConnectPlugin);
        };

        service.checkLoginStatus = function () {
            return $q(function (resolve, reject) {
                if (service.hasPlugin()) {
                    facebookConnectPlugin.getLoginStatus(function (result) {
                        if (result.status === 'connected') {
                            resolve(result);
                        } else if (result.status === 'not_authorized') {
                            // the user is logged in to Facebook, but has not authenticated
                            reject(result);
                        } else {
                            // the user isn't logged in to Facebook
                            reject(result);
                        }
                    }, reject);
                } else {
                    reject();
                }
            });
        };

        service.getFriends = function () {
            return $q(function (resolve, reject) {
                if (service.hasPlugin()) {
                    (function () {
                        // TODO verify that paging works... need a lot of friends for that!
                        var friends = [];
                        var getPage = function getPage(url, done) {
                            facebookConnectPlugin.api(url, ['user_friends'], function (result) {
                                Array.prototype.push.apply(friends, result.data);

                                if (result && result.paging && result.paging.next) {
                                    getPage(result.paging.next, done);
                                } else {
                                    done(true);
                                }
                            }, function (error) {
                                return done(false);
                            });
                        };

                        getPage('/me/friends', function (success) {
                            if (success) {
                                resolve(friends);
                            } else {
                                reject();
                            }
                        });
                    })();
                } else {
                    reject();
                }
            });
        };

        service.updateFriends = function (friends) {
            return ApiService.request('addfollowersfromsocialPost', {}, {
                Idlist: friends.map(function (friend) {
                    return friend.id;
                }),
                type: 'facebook'
            }).then(function (response) {
                return UserService.friends = response.data.Attributes.friends || [];
            });
        };

        service.getMyInfo = function () {
            return $q(function (resolve, reject) {
                if (service.hasPlugin()) {
                    facebookConnectPlugin.api('/me?fields=name,email,location,gender,birthday', ['email', 'user_location', 'user_birthday'], resolve, reject);
                } else {
                    reject('Facebook plugin not present');
                }
            });
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('ImageUriService', ImageUriService);

    ImageUriService.$inject = [];

    function ImageUriService() {
        var service = {};

        service.currentImageUri = null;

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('IOIService', IOIService);

    IOIService.$inject = ['$q', '$filter', 'moment', 'ApiService', 'LocationService'];

    function IOIService($q, $filter, moment, ApiService, LocationService) {
        var service = {};

        service.currentIois = [];

        service.getIoisForIds = function (ids) {
            if (LocationService.hasLocation) {
                var queryParams = {
                    idList: ids || LocationService.locations.map(function (location) {
                        return location.place_id;
                    })
                };

                return ApiService.request('ioiGet', queryParams, {}, { queryParams: queryParams });
            } else {
                return $q.reject('Location not available');
            }
        };

        service.prepareIoiList = function (iois) {
            var locationsList = LocationService.locations.map(function (loc) {
                iois.forEach(function (ioi) {
                    if (loc.place_id == ioi.ioiId) {
                        loc.ioi = ioi;
                    }
                });
                return loc;
            });
            return locationsList;
        };

        service.getNearby = function (coords, categories) {
            if (coords) {
                // good to go!
            } else if (LocationService.hasLocation) {
                coords = LocationService.lastKnownLocation.coords;
            } else {
                return $q.reject('Location not available');
            }

            return ApiService.request('ioiRecommendedGet', {
                location: [coords.latitude, coords.longitude].join(','),
                categoryList: categories.join(',')
            }).then(function (response) {
                return {
                    boundingBox: response.data.boundingBoxCoordinates,
                    categories: response.data.localCategories,
                    items: response.data.Items.map(function (item) {
                        var newItem = {
                            placeId: item.ioiId,
                            ioiId: item.ioiId,
                            title: item.title,
                            address: item.address || '',
                            phone: item.phone || '',
                            loveCount: item.loveCount || 0,
                            okCount: item.okCount || 0,
                            hateCount: item.hateCount || 0,
                            closingTime: item.closingTimes ? item.closingTimes[moment().day()] : false,
                            distance: LocationService.getDistance(item.geometry.location.lat, item.geometry.location.lng),
                            categories: (item.category || '').split(','),
                            coords: {
                                latitude: item.geometry.location.lat,
                                longitude: item.geometry.location.lng
                            },
                            isMob: item.mobCount > 0
                        };

                        newItem.count = newItem.loveCount + newItem.okCount + newItem.hateCount;

                        var largest = Math.max(newItem.loveCount, newItem.okCount, newItem.hateCount);

                        if (largest === newItem.loveCount) {
                            newItem.rating = 'love';
                        } else if (largest === newItem.okCount) {
                            newItem.rating = 'ok';
                        } else if (largest === newItem.hateCount) {
                            newItem.rating = 'hate';
                        }

                        return newItem;
                    })
                };
            });
        };

        service.getThings = function (searchString) {
            return getByType('thing', searchString);
        };

        service.getPeople = function (searchString) {
            return getByType('person', searchString);
        };

        service.addItem = function (item) {
            /**
             * `item` should look like { "type": "thing", "source": "FTAP", "title": "plane" }
             */

            return ApiService.request('ioiPut', null, angular.extend({ source: 'FTAP' }, item)).then(function (response) {
                return response.data;
            });
        };

        return service;

        function getByType(type, searchString) {
            searchString = '' + (searchString || ''); // cast to string
            var queryParams = { type: type, searchString: searchString };

            return ApiService.request('ioiByTypeGet', queryParams, {}, { queryParams: queryParams }).then(function (response) {
                response.data.FilterText = response.data.FilterText || searchString;
                response.data.Items.forEach(function (item) {
                    return item.formattedRatingCount = $filter('shortNumber')(item.totalCount);
                });

                return response.data;
            });
        };
    }
})();
'use strict';

/**
 * Fetch and record locations for Google Places API
 */
(function () {
    'use strict';

    angular.module('ftap').factory('LocationService', LocationService);

    LocationService.$inject = ['$http', '$q', '$timeout', '$window', '$interval', '$cordovaGeolocation', '$injector', '$filter', 'moment', 'lodash', 'FTAP_CONFIG', 'AnalyticsService'];

    function LocationService($http, $q, $timeout, $window, $interval, $cordovaGeolocation, $injector, $filter, moment, lodash, FTAP_CONFIG, AnalyticsService) {
        var service = {};
        // Location list acquired from Google Places
        service.locations = [];
        // Keep track of last error when trying to retrieve location list
        service.lastError = null;
        // Used for throttling watchPosition updates
        service.lastWatchChange = 0;
        // Keep track of user's last known location
        service.lastKnownLocation = false;
        // place types to get from Google places
        // This is the default list, but an updated list is acquired from
        // S3 upon initialization
        service.placeTypes = ["airport", "amusement_park", "aquarium", "bakery", "bar", "cafe", "car_rental", "clothing_store", "department_store", "florist", "food", "grocery_or_supermarket", "gym", "hair_care", "home_goods_store", "jewelry_store", "movie_theater", "night_club", "restaurant", "shopping_mall", "spa", "stadium", "store", "train_station", "zoo"];

        /**
         * Transforms array of business opening hours into an array of closing times for use in map popups. Example:
         *
         * Input:
         *
         * {
         *     "open_now": true,
         *     "periods": [
         *         { "close": { "day": 0, "time": "1700" }, "open": { "day": 0, "time": "1000" } },
         *         { "close": { "day": 1, "time": "2200" }, "open": { "day": 1, "time": "0800" } },
         *         { "close": { "day": 2, "time": "2200" }, "open": { "day": 2, "time": "0800" } },
         *         { "close": { "day": 3, "time": "2200" }, "open": { "day": 3, "time": "0800" } },
         *         { "close": { "day": 5, "time": "0200" }, "open": { "day": 4, "time": "0800" } },
         *         { "close": { "day": 6, "time": "0200" }, "open": { "day": 5, "time": "0800" } },
         *         { "close": { "day": 0, "time": "0200" }, "open": { "day": 6, "time": "0800" } }
         *     ],
         *     "weekday_text": [ "Monday: 8:00 AM – 10:00 PM", "Tuesday: 8:00 AM – 10:00 PM", ... ]
         * }
         *
         * Output:
         *
         * { 0: "5:00 PM", 1: "10:00 PM", 2: "10:00 PM", 3: "10:00 PM", 4: "2:00 AM", 5: "2:00 AM", 6: "2:00 AM" }
         *
         * N.B. If a place is open 24 hours, the `periods` will look like so:
         *
         * "periods" : [
         *     { "open" : { "day" : 0, "time" : "0000" } }
         * ]
         */

        service.getClosingTimes = function (openingHours) {
            if (openingHours.periods.length === 1 && openingHours.periods[0].open && !openingHours.periods[0].close) {
                return lodash.range(0, 7).reduce(function (times, day) {
                    times[day] = '24 hours';
                    return times;
                }, {});
            }

            return openingHours.periods.reduce(function (times, period) {
                var time = moment(period.close.time, 'HHmm');

                if (time.isValid()) {
                    times[period.open.day] = time.format('h:mm A'); // use the day from the opening time to handle
                } // cases where closing time is the next day

                return times;
            }, {});
        };

        service.locationSearch = function (searchString, onlyEstablishments) {
            return $q(function (resolve, reject) {
                searchString = '' + (searchString || ''); // cast to string

                if (searchString.length < 3) {
                    resolve([]);
                }

                var autocomplete = new $window.google.maps.places.AutocompleteService();
                var request = { input: searchString };

                if (onlyEstablishments) {
                    request.types = ['establishment'];
                }

                if (service.hasLocation) {
                    request.radius = 40234; // in meters (40234 m ~= 25 mi) -- required when using `location`
                    request.location = new $window.google.maps.LatLng(service.lastKnownLocation.coords.latitude, service.lastKnownLocation.coords.longitude);
                }

                autocomplete.getPlacePredictions(request, function (results, status) {
                    if (status != google.maps.places.PlacesServiceStatus.OK) {
                        console.error('Google Maps error: ' + status);
                        console.error(results);

                        return reject(results);
                    }

                    console.log(results);
                    resolve(results);
                });
            });
        };

        service.hasLocation = false;

        service.watchId = false;

        service.getCoordinates = function (searchString) {
            return $q(function (resolve, reject) {
                var maps = $window.google.maps;
                var geocoder = new maps.Geocoder();

                geocoder.geocode({
                    address: searchString
                }, function (result, status) {
                    console.log(result);

                    if (status === maps.GeocoderStatus.OK) {
                        resolve({
                            latitude: result[0].geometry.location.lat(),
                            longitude: result[0].geometry.location.lng()
                        });
                    } else {
                        reject(result);
                    }
                });
            });
        };

        /**
         * Retrieve place name from Google Places API based on lat/lng coords
         */
        service.getPlaceName = function (coords) {
            return $q(function (resolve, reject) {
                var maps = $window.google.maps;
                var geocoder = new maps.Geocoder();

                geocoder.geocode({
                    location: coords
                }, function (result, status) {
                    if (status === google.maps.GeocoderStatus.OK) {
                        // https://developers.google.com/maps/documentation/geocoding/intro#GeocodingResponses
                        var city = void 0,
                            state = void 0,
                            country = void 0;
                        var components = result[0].address_components; // assume the first result is most accurate

                        for (var i = 0; i < components.length; i++) {
                            var types = components[i].types;

                            for (var j = 0; j < types.length; j++) {
                                if (types[j] === 'country') {
                                    country = components[i].short_name;
                                } else if (types[j] === 'administrative_area_level_1') {
                                    // state (US)
                                    state = components[i].short_name;
                                } else if (types[j] === 'locality') {
                                    // city/town (US)
                                    city = components[i].long_name;
                                }
                            }
                        }

                        var pieces = [];

                        if (city) {
                            pieces.push(city);
                        }

                        if (state) {
                            pieces.push(state);
                        }

                        if (country) {
                            pieces.push(country);
                        }

                        resolve(pieces.join(', '));
                    } else {
                        reject(result);
                    }
                });
            });
        };

        /**
         * Retrieve locations from Google Places API and update service's
         * location list
         */
        service.fetchLocations = function (position) {
            var maps = $window.google.maps;

            new maps.places.PlacesService(document.createElement('div')).nearbySearch({
                location: new maps.LatLng(position.coords.latitude, position.coords.longitude),
                rankBy: maps.places.RankBy.DISTANCE,
                types: service.placeTypes
            }, function (results, status) {
                if (status === maps.places.PlacesServiceStatus.OK) {
                    (function () {
                        // Remove any locality/political locations
                        var locations = results.filter(function (location) {
                            return -1 === location.types.indexOf('locality') && -1 === location.types.indexOf('political');
                        }).map(function (location) {
                            return {
                                place_id: location.place_id,
                                name: location.name,
                                geometry: location.geometry,
                                addr: location.vicinity,
                                distance: service.getDistance(location.geometry.location.lat(), location.geometry.location.lng()),
                                type: location.types[0],
                                types: location.types.filter(function (type) {
                                    return type !== 'establishment' && type !== 'point_of_interest';
                                })
                            };
                        });

                        var IOIService = $injector.get('IOIService');

                        IOIService.getIoisForIds(locations.map(function (location) {
                            return location.place_id;
                        })).then(function (response) {
                            var iois = response.data.reduce(function (iois, ioi) {
                                iois[ioi.ioiId] = ioi;
                                return iois;
                            }, {});

                            locations.forEach(function (location) {
                                if (iois.hasOwnProperty(location.place_id)) {
                                    var ioi = iois[location.place_id];
                                    var largest = Math.max(ioi.loveCount, ioi.okCount, ioi.hateCount);

                                    location.ioiId = ioi.ioiId;

                                    if (largest === ioi.loveCount) {
                                        location.ratingType = 'love';
                                    } else if (largest === ioi.okCount) {
                                        location.ratingType = 'ok';
                                    } else if (largest === ioi.hateCount) {
                                        location.ratingType = 'hate';
                                    }

                                    location.ratingCount = ioi.loveCount + ioi.okCount + ioi.hateCount;
                                } else {
                                    location.ratingType = '';
                                    location.ratingCount = 0;
                                }

                                location.formattedRatingCount = $filter('shortNumber')(location.ratingCount);
                            });

                            service.lastError = null;
                            service.locations = locations;

                            // Send new locations to native plugin
                            if (angular.isDefined($window.NativeTap)) {
                                NativeTap.setLocations(service.locations);
                            }
                        }).catch(function (err) {
                            console.log(err);
                            service.lastError = err;
                        });
                    })();
                }
                // Handle error on position change and clear locations
                else {
                        console.error("Error retrieving places from Google");
                        console.error(status);
                        console.error(results);
                        service.locations = [];
                        service.lastError = results;
                    }
            });
        };

        service.init = function () {
            if (service.watchId) {
                $cordovaGeolocation.clearWatch(service.watchId);
                service.watchId = false;
            }

            service.watchId = $cordovaGeolocation.watchPosition({ enableHighAccuracy: false });

            service.watchId.then(null, function (err) {
                console.error("Error watching position change");
                console.error(JSON.stringify(err));

                service.locations = [];
                service.lastError = err;
                service.lastKnownLocation = false;
                service.lastWatchChange = 0;
                service.hasLocation = false;
            }, function (position) {
                var now = new Date();
                // Do not update location list if the position has changed
                // after less than a minute
                if (now - service.lastWatchChange > 60000) {
                    service.lastKnownLocation = position;
                    service.lastWatchChange = now;
                    service.hasLocation = true;

                    if (!localStorage.ANALYTICS_ENABLE_LOCATION_SENT) {
                        localStorage.ANALYTICS_ENABLE_LOCATION_SENT = 'true';
                        AnalyticsService.recordEvent('ENABLE_LOCATION', 'Enable Location');
                    }

                    return service.fetchLocations(position);
                }
            });

            service.fetchPlaceTypes();
        };

        service.startUp = function () {
            // Wait for google API to become available
            var checkGoogleAvailability = $interval(function () {
                if (angular.isDefined($window.google)) {
                    $interval.cancel(checkGoogleAvailability);

                    service.init();
                }
            }, 1000);
        };

        service.getPlaceDetails = function (placeId) {
            return $q(function (resolve, reject) {
                var maps = $window.google.maps;

                new maps.places.PlacesService(document.createElement('div')).getDetails({ placeId: placeId }, function (place, status) {
                    if (status == google.maps.places.PlacesServiceStatus.OK) {
                        resolve(place);
                    } else {
                        console.error('Google Maps error: ' + status);
                        console.error(place);

                        reject(place);
                    }
                });
            });
        };

        service.fetchPlaceTypes = function () {
            return $http.get('https://s3.amazonaws.com/' + FTAP_CONFIG.S3_RESOURCE_BUCKET + '/place-types.json').then(function (response) {
                return service.placeTypes = response.data;
            });
        };

        /**
         * Get the distance between a lat/long point and the user's last known location.  Returns distance in feet if
         * distance < 0.1 mi or miles if >= 0.1 mi.  Returns null on error (most likely no last known location)
         */
        service.getDistance = function (lat, lng) {
            try {
                var distance = geolib.getDistance(service.lastKnownLocation.coords, { latitude: lat, longitude: lng });

                return geolib.convertUnit('mi', distance) >= 0.1 ? geolib.convertUnit('mi', distance, 1) + ' mi' : geolib.convertUnit('ft', distance, 0) + ' ft';
            } catch (e) {
                console.error(e);
                return null;
            }
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('ObservationService', ObservationService);

    ObservationService.$inject = ['$q', '$window', '$cordovaDialogs', 'CameraService', 'ApiService', 'S3Service', 'UserService', 'LocationService', 'PushNotificationService'];

    function ObservationService($q, $window, $cordovaDialogs, CameraService, ApiService, S3Service, UserService, LocationService, PushNotificationService) {
        var service = {};

        service.placeToView = null;

        service.send = function (imageUri, observation) {
            return $q.when().then(function () {
                if (observation.hasOwnProperty('place_id')) {
                    observation.type = 'place';
                }

                if (UserService.username) {
                    observation.username = UserService.username;
                }

                if (UserService.name) {
                    observation.name = UserService.name;
                }

                if (UserService.thumbnailLink) {
                    observation.photoLink = UserService.thumbnailLink;
                } else if (UserService.photoLink) {
                    observation.photoLink = UserService.photoLink;
                }

                return observation.place_id ? LocationService.getPlaceDetails(observation.place_id) : $q.when(false);
            }).then(function (place) {
                if (place) {
                    observation.geometry = place.geometry;
                    observation.title = place.name;
                    observation.category = place.types.join(',');

                    if (place.formatted_address) {
                        observation.address = place.formatted_address;
                    }

                    if (place.formatted_phone_number) {
                        observation.phone = place.formatted_phone_number;
                    }

                    if (place.opening_hours) {
                        observation.closingTimes = LocationService.getClosingTimes(place.opening_hours);
                    }
                }

                if (observation.title.length > 40) {
                    observation.title = observation.title.substring(0, 37) + "...";
                }
            }).then(function () {
                return imageUri ? CameraService.crop(imageUri, 1080, 1080, true).then(function (blob) {
                    return S3Service.uploadPhoto(blob);
                }).then(function (result) {
                    return result.Location;
                }) : false;
            }).then(function (imageUrl) {
                var queryParams = { feedType: 'Obs' };

                if (imageUrl) {
                    observation.imageUrl = imageUrl;
                }

                return ApiService.request('observationPut', queryParams, observation, { queryParams: queryParams });
            }).then(function (response) {
                if (angular.isDefined('NativeTap')) {
                    NativeTap.sendTapSuccess();
                }

                return response;
            }).catch(function (err) {
                if (angular.isDefined('NativeTap')) {
                    NativeTap.sendTapFailure();
                }

                return $q.reject(err);
            });
        };

        service.observationFeed = function () {
            var queryParams = { movementFeed: '' };

            return ApiService.request('observationfeedGet', queryParams, {}, { queryParams: queryParams });
        };

        service.upvotedObservationFeed = function () {
            var queryParams = { movementFeed: '1' };

            return ApiService.request('observationfeedGet', queryParams, {}, { queryParams: queryParams });
        };

        service.friendFeed = function (friends) {
            var cogIds = friends.map(function (el) {
                return el.cogId;
            }).join();
            var queryParams = {
                idList: cogIds,
                onLocation: '',
                mobsOnly: ''
            };

            return ApiService.request('feedGet', queryParams, {}, { queryParams: queryParams });
        };

        service.observationDetails = function (observationId) {
            return ApiService.request('observationGet', {
                observationId: observationId
            }, {}, { queryParams: { observationId: observationId } });
        };

        service.join = function (mob) {
            var queryParams = { feedType: 'Agr' };
            var cogId = AWS.config.credentials.identityId;

            if (typeof mob === 'string') {
                mob = {
                    upvoteCount: 0,
                    isMobMember: false,
                    mobId: mob
                };
            }

            mob.upvoteCount++;
            mob.isMobMember = true;

            return ApiService.request('observationPut', queryParams, { upvotedMobId: mob.mobId }, { queryParams: queryParams }).then(function () {
                if (!PushNotificationService.hasSeenNudge()) {
                    PushNotificationService.promptToEnable();
                } else {
                    PushNotificationService.checkIfEnabled().then(function () {/* user has notifications enabled, no action required */}).catch(function (err) {
                        if (!localStorage.PUSH_NOTIFICATION_REMINDER_SEEN) {
                            $cordovaDialogs.alert("If you would like to receive notifications regarding this Mob and others " + "you've joined, please turn them on in your application settings.", '', 'OK');
                            localStorage.PUSH_NOTIFICATION_REMINDER_SEEN = true;
                        }
                    });
                }
            }).catch(function (err) {
                $cordovaDialogs.alert("We're sorry, an error occurred when you tried to join this Mob.", '', 'OK');
                mob.upvoteCount--;
                mob.isMobMember = false;

                return $q.reject(err);
            });
        };

        service.getTapsForLocation = function (placeId) {
            var queryParams = {
                idList: placeId,
                onLocation: 1,
                mobsOnly: ''
            };

            return ApiService.request('feedGet', queryParams, {}, { queryParams: queryParams }).then(function (response) {
                return response.data;
            });
        };

        service.getMobsForLocation = function (placeId) {
            var queryParams = {
                idList: placeId,
                onLocation: 1,
                mobsOnly: 1
            };

            return ApiService.request('feedGet', queryParams, {}, { queryParams: queryParams }).then(function (response) {
                return response.data;
            });
        };

        service.getRelatedTaps = function (combinedDescription) {
            var queryParams = { combinedDescription: combinedDescription };

            return ApiService.request('feedByMobGet', queryParams, {}, { queryParams: queryParams }).then(function (response) {
                return response.data.Items;
            });
        };

        service.getMobs = function (type, coords) {
            var queryParams = {
                type: type,
                location: (coords ? [coords.latitude, coords.longitude] : []).join(',')
            };

            return ApiService.request('feedByTypeGet', queryParams, {}, { queryParams: queryParams }).then(function (response) {
                if (LocationService.hasLocation) {
                    response.data.forEach(function (item) {
                        if (item.geometry) {
                            item.distance = LocationService.getDistance(item.geometry.location.lat, item.geometry.location.lng);
                        }
                    });
                }

                return response.data;
            });
        };

        service.searchMobs = function (type, searchString) {
            var queryParams = { type: type, searchString: searchString };

            return ApiService.request('feedSearchGet', queryParams, {}, { queryParams: queryParams }).then(function (response) {
                var results = response.data.Items;

                if (LocationService.hasLocation) {
                    results.forEach(function (item) {
                        if (item.geometry) {
                            item.distance = LocationService.getDistance(item.geometry.location.lat, item.geometry.location.lng);
                        }
                    });
                }

                return results;
            });
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('PlatformService', PlatformService);

    PlatformService.$inject = [];

    function PlatformService() {
        return ionic.Platform;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('ProfilePictureService', ProfilePictureService);

    ProfilePictureService.$inject = ['CameraService', 'S3Service', 'UserService', 'ApiService'];

    function ProfilePictureService(CameraService, S3Service, UserService, ApiService) {
        var service = {};

        service.takeProfilePicture = function () {
            return CameraService.getPicture().then(function (imageUri) {
                return CameraService.crop(imageUri, 400, 400, true);
            });
        };

        service.uploadProfilePicture = function (blob) {
            return S3Service.uploadPhoto(blob, 'profile/profile').then(function (result) {
                return service.setProfilePicture(result.Location);
            });
        }; // result.Location is url

        service.getFacebookProfilePictureUrl = function () {
            return UserService.socialId ? 'https://graph.facebook.com/' + UserService.socialId + '/picture?width=400&height=400' : null;
        };

        service.useFacebookProfilePicture = function () {
            return service.setProfilePicture(service.getFacebookProfilePictureUrl());
        };

        service.setProfilePicture = function (url) {
            return ApiService.request('adduserphotoPost', {}, {
                photoLink: url
            }).then(function (response) {
                UserService.photoLink = response.data.Attributes.photoLink;
                UserService.thumbnailLink = UserService.photoLink ? UserService.photoLink.replace('/profile/profile.png', '/profile-thumbnail/profile-resized.png' + '?' + Date.now()) : '';

                return UserService.photoLink;
            });
        };

        return service;
    }
})();
'use strict';

// Subscribe user to push notifications
(function () {
    'use strict';

    angular.module('ftap').factory('PushNotificationService', PushNotificationService);

    PushNotificationService.$inject = ['$q', '$state', '$window', '$ionicPlatform', 'FTAP_CONFIG', 'ApiService', 'PlatformService', 'EnableNotificationModalService', 'UserService'];

    function PushNotificationService($q, $state, $window, $ionicPlatform, FTAP_CONFIG, ApiService, PlatformService, EnableNotificationModalService, UserService) {

        var service = {
            hasSeenNudge: hasSeenNudge,
            hasSubscribed: hasSubscribed,
            promptToEnable: promptToEnable,
            register: register,
            subscribe: subscribe,
            checkIfEnabled: checkIfEnabled
        };

        function hasSeenNudge() {
            return $window.localStorage.getItem('PUSH_NOTIFICATION_NUDGE_SEEN') === 'true';
        }

        function hasSubscribed() {
            return $window.localStorage.getItem('DEVICE_HAS_REGISTERED_FOR_PUSH') === 'true';
        }

        function promptToEnable() {
            $window.localStorage.setItem('PUSH_NOTIFICATION_NUDGE_SEEN', 'true');

            return EnableNotificationModalService.showModal().then(function () {
                return service.register();
            });
        }

        function register() {
            $ionicPlatform.ready(function () {
                if ($window.PushNotification) {
                    var push = $window.PushNotification.init({
                        android: {
                            senderID: FTAP_CONFIG.GCM_SENDER_ID,
                            icon: 'ic_stat_droid_notification',
                            iconColor: '#003D99'
                        },
                        ios: {
                            alert: true
                        }
                    });

                    if (!hasSubscribed()) {
                        push.on('registration', function (data) {
                            return subscribe(data.registrationId, PlatformService.isIOS() ? 'ios' : 'android');
                        });
                    }

                    push.on('notification', function () {
                        return $state.go('main.profile.my-mobs');
                    });

                    push.on('error', function (err) {
                        return console.error(err);
                    });
                }
            });
        }

        function subscribe(token, platform) {
            ApiService.request('registerdevicePost', {}, { token: token, platform: platform }, {}).then(function () {
                return $window.localStorage.setItem('DEVICE_HAS_REGISTERED_FOR_PUSH', 'true');
            }).catch(function (err) {
                return console.error(err);
            });
        }

        function checkIfEnabled() {
            if (angular.isUndefined($window.PushNotification)) {
                UserService.notifs = 0;
                return $q.reject('Push notification plugin not present');
            }

            return $q(function (resolve, reject) {
                return PushNotification.hasPermission(function (data) {
                    if (data.isEnabled) {
                        UserService.notifs = 1;
                        resolve();
                    } else {
                        UserService.notifs = 0;
                        reject('Push notifications not enabled');
                    }
                });
            });
        }

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('S3Service', S3Service);

    S3Service.$inject = ['$q', 'FTAP_CONFIG', 'UserService'];

    function S3Service($q, FTAP_CONFIG, UserService) {
        var service = {};

        // Upload user-specific photos for Taps and profile pictures
        service.uploadPhoto = function (blob, name) {
            return $q(function (resolve, reject) {
                name = name || Date.now();

                var bucket = new AWS.S3({
                    params: {
                        Bucket: FTAP_CONFIG.S3_PHOTO_BUCKET
                    }
                });

                bucket.upload({
                    Key: AWS.config.credentials.identityId + '/' + name + '.png', // filename
                    Body: blob,
                    ContentType: 'image/png'
                }, function (err, data) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(data);
                    }
                });
            });
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('SharingService', SharingService);

    SharingService.$inject = ['$window'];

    function SharingService($window) {
        var service = {
            get facebook() {
                return localStorage.getItem('FTAP_SHARE_FACEBOOK') === 'true';
            },

            set facebook(value) {
                localStorage.setItem('FTAP_SHARE_FACEBOOK', !!value);

                // Update NativeTap with default sharing selection
                if ($window.NativeTap) {
                    NativeTap.setProfileSettings({
                        isFbSharingEnabledDefault: !!value
                    });
                }
            }
        };

        // set default value if localStorage key doesn't yet exist
        if (localStorage.getItem('FTAP_SHARE_FACEBOOK') === null) {
            localStorage.setItem('FTAP_SHARE_FACEBOOK', false);
        }

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('TabsService', TabsService);

    TabsService.$inject = [];

    function TabsService() {
        var service = {};

        service.tabsActive = true;

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('TapParamsService', TapParamsService);

    TapParamsService.$inject = [];

    /**
     * because of the way Ionic and ui-router handle sub-states (and all states are substates of 'main')
     * state params are never cleared once set
     * therefore, after the first time user goes to the tap screen from Location details
     * all consecutive entries to the tap screen bring up the same location
     * a way around it is to use a service to pass the rating and place id
     * instead of state params.
     */
    function TapParamsService() {
        var service = {};

        service.rating = false;
        service.place_id = false;
        service.hasParams = function () {
            return service.rating && service.place_id;
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('UserService', UserService);

    UserService.$inject = ['ApiService'];

    function UserService(ApiService) {
        var service = {
            cogId: null,
            socialId: null,
            username: null,
            name: null,
            email: null,
            location: null,
            photoLink: null,
            thumbnailLink: null,
            gender: null,
            birthYear: null,
            loveCount: 0,
            hateCount: 0,
            okCount: 0,
            notifs: 0,
            timestamp: null,
            // List of IDs for friends/followers
            friends: []
        };

        service.registerUser = function (socialId, email, photoLink, username) {
            var userInfo = {};

            if (socialId) {
                userInfo.socialId = socialId;
            }

            if (email) {
                userInfo.email = email;
            }

            if (photoLink) {
                userInfo.photoLink = photoLink;
            }

            if (username) {
                userInfo.username = username;
            }

            if (!username && !socialId) {
                userInfo.status = 'anonymous';
            } else {
                userInfo.status = 'facebook';
            }

            return ApiService.request('registeruserPost', {}, userInfo).then(function (response) {
                // Set user default data post-login
                // cognito ID is used as user identifier and friends
                // list is used to generate feeds
                service.cogId = AWS.config.credentials.identityId;
                service.friends = response.data.friends || [];
                service.photoLink = response.data.photoLink;
                service.thumbnailLink = service.photoLink ? service.photoLink.replace('/profile/profile.png', '/profile-thumbnail/profile-resized.png') : '';
                service.timestamp = response.data.timestamp.split("T")[0];

                // Update counts on load and after tap, for analytics
                service.loveCount = response.data.loveCount;
                service.hateCount = response.data.hateCount;
                service.okCount = response.data.okCount;

                return response;
            });
        };

        service.updateSocialId = function (photoLink) {
            ApiService.request('linkaccountsPost', {}, {
                email: service.email,
                location: service.location,
                name: service.name,
                photoLink: photoLink,
                socialid: service.socialId,
                status: 'facebook'
            });
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').component('ftJoinMob', {
        templateUrl: 'app/directives/join-mob/join-mob.html',
        bindings: {
            mob: '<'
        },
        controller: ['$cordovaDialogs', 'ObservationService', 'UserService', 'PushNotificationService', function ($cordovaDialogs, ObservationService, UserService, PushNotificationService) {
            var cogId = AWS.config.credentials.identityId;
            /**
             * Join the associated mob if the user is not already a member.
             * This is done in asynchronously to the user; errors attempt
             * to roll back incorrectly reflected changes
             */
            this.joinMob = function (mob) {
                if (mob.isMobMember) {
                    return;
                }

                ObservationService.join(mob);
            };
        }]
    });
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').component('ftMobList', {
        templateUrl: 'app/directives/mob-list/mob-list.html',
        bindings: {
            mobs: '<'
        },
        controller: ['ObservationModalService', function (ObservationModalService) {
            this.openMovement = function (mob) {
                ObservationModalService.showModal(mob).catch(function (err) {
                    return console.error(err);
                });
            };
        }]
    });
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').directive('ftNavSelector', ftNavSelector);

    function ftNavSelector() {
        return {
            restrict: 'E',
            templateUrl: 'app/directives/nav-selector/nav-selector.html',
            scope: true,
            controller: ['$filter', function ($filter) {
                var _this = this;

                this.states = [];

                this.selectedClass = function () {
                    return _this.states.map(function (state, index) {
                        return $filter('isState')(state.name) ? 'ft-nav-selected-' + (index + 1) + ' ft-nav-' + _this.states.length + '-items' : '';
                    }).join(' ');
                };
            }],
            controllerAs: 'navCtrl',
            link: function link(scope, element, attrs) {
                return attrs.$observe('states', function (value) {
                    return scope.navCtrl.states = scope.$eval(value);
                });
            }
        };
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').component('ftToggle', {
        templateUrl: 'app/directives/toggle/toggle.html',
        bindings: {
            type: '@?',
            value: '='
        }
    });
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('EnableNotificationModalService', EnableNotificationModalService);

    EnableNotificationModalService.$inject = ['$q', '$rootScope', '$ionicModal', 'AnalyticsService'];

    function EnableNotificationModalService($q, $rootScope, $ionicModal, AnalyticsService) {
        var service = {};

        service.showModal = function () {
            return $q(function (resolve, reject) {
                var scope = $rootScope.$new();

                scope.close = function () {
                    return scope && scope.modal ? scope.modal.hide().then(function () {
                        return scope.modal.remove();
                    }) : $q.when();
                };

                scope.confirm = function () {
                    return scope.close().then(resolve);
                };

                scope.cancel = function () {
                    return scope.close().then(reject);
                };

                scope.$on('$destroy', function () {
                    scope && scope.modal && scope.modal.remove();
                });

                $ionicModal.fromTemplateUrl('app/modals/enable-notification/enable-notification.html', {
                    scope: scope,
                    backdropClickToClose: false
                }).then(function (modal) {
                    scope.modal = modal;
                    scope.modal.show();

                    AnalyticsService.screenView('Enable Notification');
                });
            });
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('ObservationModalController', ObservationModalController);

    ObservationModalController.$inject = ['$cordovaDialogs', 'ObservationService', 'ObservationModalService', 'AnalyticsService'];

    function ObservationModalController($cordovaDialogs, ObservationService, ObservationModalService, AnalyticsService) {
        var self = this;

        var screenName = 'Post';

        self.closeModal = closeModal;
        self.item = ObservationModalService.item;

        activate();

        function activate() {
            AnalyticsService.screenView(screenName);
            AnalyticsService.recordEvent('VIEWPOST', screenName, {
                ctx_locName: self.item.title,
                ctx_locAddress: self.item.address,
                ctx_sentiment: self.item.rating,
                ctx_postDate: self.item.timestamp
            }, {
                ctx_numJoins: self.item.upvoteCount
            });
        }

        function closeModal() {
            AnalyticsService.recordEvent('CLOSEPOST', screenName, {
                ctx_locName: self.item.title,
                ctx_locAddress: self.item.address,
                ctx_sentiment: self.item.rating,
                ctx_postDate: self.item.timestamp
            }, {
                ctx_numJoins: self.item.upvoteCount
            });

            ObservationModalService.modal.hide().then(function () {
                return ObservationModalService.modal.remove();
            }).then(function () {
                self.item = null;
                ObservationModalService.item = null;
            });
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('ObservationModalService', ObservationModalService);

    ObservationModalService.$inject = ['$ionicModal'];

    function ObservationModalService($ionicModal) {
        var service = {};

        service.item = null;
        service.modal = null;

        /**
         * Initialize the observation to display and show the modal
         */
        service.showModal = function (item) {
            service.item = item;

            return $ionicModal.fromTemplateUrl('app/modals/observation-modal/observation-modal.html', {
                backdropClickToClose: false
            }).then(function (modal) {
                service.modal = modal;
                return service.modal.show();
            });
        };

        return service;
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('TapDetailsModalController', TapDetailsModalController);

    TapDetailsModalController.$inject = ['$q', '$window', '$state', '$timeout', '$ionicLoading', 'LocationService', 'TapDetailsModalService', 'ObservationService', 'TapParamsService', 'AnalyticsService'];

    function TapDetailsModalController($q, $window, $state, $timeout, $ionicLoading, LocationService, TapDetailsModalService, ObservationService, TapParamsService, AnalyticsService) {
        var self = this;

        self.hasPlace = false;
        self.place = null;
        self.loaded = false;
        self.mobs = [];

        self.tapScreen = tapScreen;
        self.closeModal = closeModal;
        self.viewMobs = viewMobs;

        activate();

        function activate() {
            AnalyticsService.screenView('Tap Details');

            var getDetailsPromise;

            // Only places should go through the google maps api...
            if (TapDetailsModalService.category === "places") {
                getDetailsPromise = LocationService.getPlaceDetails(!!TapDetailsModalService.mob ? TapDetailsModalService.mob.place_id : TapDetailsModalService.placeId);
            }

            // Things and People should just return the necessary data for the modal
            else {
                    getDetailsPromise = $q(function (resolve, reject) {
                        resolve(TapDetailsModalService.mob);
                    });
                }

            var getListPromise = !!TapDetailsModalService.mob ? ObservationService.getRelatedTaps(TapDetailsModalService.mob.combinedDescription) : ObservationService.getTapsForLocation(TapDetailsModalService.placeId);

            $ionicLoading.show().then(function () {
                return $q.all([
                // retrieve place name + address
                getDetailsPromise.then(function (place) {
                    return self.place = place;
                }),

                // retrieve taps/mobs for place
                getListPromise.then(function (data) {
                    return self.mobs = data;
                })]);
            }).catch(function (error) {
                return console.error(error);
            }).finally(function () {
                self.loaded = true;
                $ionicLoading.hide();
            });
        }

        function closeModal(clear) {
            /**
             * .hide() hides it from view via an animation, but keeps it in the DOM
             * because of which, the more modals you open (or the more times you open the same modal) the DOM keeps getting filled
             * .remove() removes the element(s) from DOM
             *
             * however, calling only .remove() makes the modal disappear, no animation
             * that's why it is chained with .hide().then()
             */

            return TapDetailsModalService.modal.hide().then(function () {
                return TapDetailsModalService.modal.remove();
            });
        }

        function tapScreen(rating) {
            if (angular.isDefined($window.NativeTap)) {
                TapDetailsModalService.modal.remove();
                NativeTap.openLocationTap(self.place, rating, null);
                AnalyticsService.recordEvent("TAP", "4.1.1 - Tap Details", {
                    "ctx_sentiment": rating,
                    "ctx_locName": self.place ? self.place.name : "N/A",
                    "ctx_locAddress": self.place ? self.place.formatted_address : "N/A"
                }, {});
            }
        }

        function viewMobs(item) {
            if (item.upvoteCount) {
                ObservationService.placeToView = {
                    title: item.title,
                    placeId: item.place_id
                };

                $state.go('main.mobs').then(function () {
                    return TapDetailsModalService.modal.remove();
                } // remove modal right away with no animation
                );
            }
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').factory('TapDetailsModalService', TapDetailsModalService);

    TapDetailsModalService.$inject = ['$ionicModal'];

    function TapDetailsModalService($ionicModal) {
        var service = {};

        service.placeId = null;
        service.mob = null;
        service.modal = null;
        service.category = null;

        service.showTapDetails = function (placeId, rating) {
            service.placeId = placeId;
            service.category = "places";
            service.mob = null;

            return showModal();
        };

        service.showMobDetails = function (mob, category) {
            if (!mob.place_id) {
                mob.place_id = null;
            }

            service.category = category;
            service.mob = mob;

            return showModal();
        };

        return service;

        function showModal() {
            return $ionicModal.fromTemplateUrl('app/modals/tap-details-modal/tap-details-modal.html', {
                backdropClickToClose: false,
                animation: 'slide-in-left'
            }).then(function (modal) {
                service.modal = modal;

                return service.modal.show();
            });
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('AuthController', AuthController);

    AuthController.$inject = ['$stateParams', '$rootScope', '$window', '$state', '$ionicPlatform', 'AuthService', 'isLoggedInFacebook', 'isAnonymous'];

    function AuthController($stateParams, $rootScope, $window, $state, $ionicPlatform, AuthService, isLoggedInFacebook, isAnonymous) {
        this.useFacebook = true;

        this.toggleFacebook = toggleFacebook;

        activate();

        function activate() {
            if ($stateParams.reload) {
                return $window.location.reload(true);
            }

            $ionicPlatform.ready(function () {
                if (angular.isDefined($window.navigator) && angular.isDefined($window.navigator.splashscreen)) {
                    $window.navigator.splashscreen.hide();
                }
            });

            $state.go(localStorage.ONBOARDING_COMPLETE ? 'main.tap' : 'onboarding');
        }

        function toggleFacebook() {
            this.useFacebook = !this.useFacebook;
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('MainController', MainController);

    MainController.$inject = ['$state', '$scope', '$window', '$timeout', '$ionicPlatform', '$ionicLoading', 'moment', 'LocationService', 'CameraService', 'FacebookService', 'TabsService', 'ImageUriService', 'IOIService', 'ObservationService', 'CannedResponseService', 'AnalyticsService', 'SharingService', 'isLoggedInFacebook', 'isAnonymous', 'UserService'];

    function MainController($state, $scope, $window, $timeout, $ionicPlatform, $ionicLoading, moment, LocationService, CameraService, FacebookService, TabsService, ImageUriService, IOIService, ObservationService, CannedResponseService, AnalyticsService, SharingService, isLoggedInFacebook, isAnonymous, UserService) {
        var self = this;

        self.TabsService = TabsService;

        activate();

        function activate() {
            updateFriends();

            $ionicPlatform.on('resume', function (event) {
                updateFriends();
            });
        }

        function updateFriends() {
            FacebookService.checkLoginStatus().then(function () {
                return FacebookService.getFriends();
            }).then(function (friends) {
                return FacebookService.updateFriends(friends);
            }).catch(function (err) {
                return console.error(err);
            });
        }

        function sendObservation(observation) {
            $ionicLoading.show().then(function () {
                return ObservationService.send(ImageUriService.currentImageUri, observation);
            }).then(function () {
                TabsService.tabsActive = true;
                ImageUriService.currentImageUri = null;

                return $state.go('main.feed', { tapCreated: true });
            }).catch(function (err) {
                console.error(err);
            }).then(function () {
                if (LocationService.hasLocation) {
                    LocationService.fetchLocations(LocationService.lastKnownLocation);
                }
            }).finally(function () {
                return $ionicLoading.hide();
            });
        }

        // native handlers are defined here to ensure that the plugin is loaded before they're called
        if (angular.isDefined($window.NativeTap)) {
            (function () {
                NativeTap.tabHandlers(function () {
                    return $scope.$apply(function () {
                        return TabsService.tabsActive = true;
                    });
                }, function () {
                    return $scope.$apply(function () {
                        return TabsService.tabsActive = false;
                    });
                });

                // Update NativeTap with information about whether the user is logged
                // into Facebook and if they have selected to share to Facebook
                // by default
                NativeTap.setProfileSettings({
                    isLoggedInFacebook: isLoggedInFacebook,
                    isFbSharingEnabledDefault: SharingService.facebook
                });

                NativeTap.requestLocationsHandler(function () {
                    if (LocationService.lastError) {
                        return NativeTap.errorLocations(LocationService.lastError);
                    }

                    NativeTap.setLocations(LocationService.locations);

                    if (!localStorage.COACH_MARKS_SEEN) {
                        localStorage.COACH_MARKS_SEEN = true;
                    }
                });

                NativeTap.getPictureHandler(function () {
                    return CameraService.getPicture().then(function (nativeUri) {
                        ImageUriService.currentImageUri = nativeUri;
                        NativeTap.setPicture(nativeUri);
                    }).catch(function (err) {
                        return console.error(err);
                    });
                });

                var getThingsTimeout = null;

                NativeTap.getThingsHandler(function (searchString) {
                    if (getThingsTimeout) {
                        $timeout.cancel(getThingsTimeout);
                    }

                    getThingsTimeout = $timeout(function () {
                        getThingsTimeout = null;

                        IOIService.getThings(searchString).then(function (data) {
                            NativeTap.setThings(data);
                            var resultsObj = {};
                            data.Items.forEach(function (el, idx) {
                                resultsObj["ctx_name_" + (idx + 1)] = el["ftap-thing"];
                            });
                            AnalyticsService.recordEvent("SEARCH_TERMS", "3.2 - Search", angular.extend({
                                "ctx_search": "person",
                                "ctx_searchTerms": searchString
                            }, resultsObj), {});
                        }).catch(function (err) {
                            console.error(err);
                            NativeTap.getThingsError(err);
                        });
                    }, 400);
                });

                var getPeopleTimeout = null;

                NativeTap.getPeopleHandler(function (searchString) {
                    if (getPeopleTimeout) {
                        $timeout.cancel(getPeopleTimeout);
                    }

                    getPeopleTimeout = $timeout(function () {
                        getPeopleTimeout = null;

                        IOIService.getPeople(searchString).then(function (data) {
                            NativeTap.setPeople(data);
                            var resultsObj = {};
                            data.Items.forEach(function (el, idx) {
                                resultsObj["ctx_name_" + (idx + 1)] = el["ftap-person"];
                            });
                            AnalyticsService.recordEvent("SEARCH_TERMS", "3.2 - Search", angular.extend({
                                "ctx_search": "person",
                                "ctx_searchTerms": searchString
                            }, resultsObj), {});
                        }).catch(function (err) {
                            console.error(err);
                            NativeTap.getPeopleError(err);
                        });
                    }, 400);
                });

                NativeTap.addItemHandler(function (item) {
                    return IOIService.addItem(item).then(function (data) {
                        NativeTap.addItemSuccess(data);
                    }).catch(function (err) {
                        NativeTap.addItemFailure(err);
                    });
                });

                var locationSearchTimeout = null;

                NativeTap.locationSearchHandler(function (searchString) {
                    searchString = (searchString || '') + ''; // cast to string

                    if (locationSearchTimeout) {
                        $timeout.cancel(locationSearchTimeout);
                    }

                    if (searchString.length < 3) {
                        NativeTap.locationSearchSuccess([]);
                    } else {
                        locationSearchTimeout = $timeout(function () {
                            locationSearchTimeout = null;

                            LocationService.locationSearch(searchString, true).then(function (results) {
                                NativeTap.locationSearchSuccess(results);
                                var resultsObj = {};
                                results.forEach(function (el, idx) {
                                    resultsObj["ctx_name_" + (idx + 1)] = el.description;
                                });

                                AnalyticsService.recordEvent("SEARCH_TERMS", "3.2 - Search", angular.extend({
                                    "ctx_search": "location",
                                    "ctx_searchTerms": searchString
                                }, resultsObj), {});
                            }).catch(function (err) {
                                console.error(err);
                                NativeTap.locationSearchFailure(err);
                            });
                        }, 400);
                    }
                });

                NativeTap.getLocationRatingResponsesHandler(function (data) {
                    /**
                     *  data = {
                     *      rating: 'love' || 'ok' || 'hate',
                     *      placeType: 'airport' || 'amusement_park' || 'jewelry_store' || ... (from ftap-observation-list.json)
                     *  };
                    */

                    return CannedResponseService.getResponses(data.ioiId, data.rating).then(function (responses) {
                        NativeTap.setLocationRatingResponses(responses);

                        // Aggregate top comments and number of reviews after we receive tap data
                        self.comments = responses.map(function (el) {
                            return el.phrase;
                        });
                        self.numReviews = responses.reduce(function (sum, el) {
                            return sum += el.count;
                        }, 0);
                    }).catch(function (err) {
                        return console.error(err);
                    });
                });

                NativeTap.sendTapHandler(function (data) {
                    /**
                     *  data = {
                     *      selectedState: 'love' || 'ok' || 'hate',
                     *      item: 'title of tapped non-location item',
                     *      location: { location object },
                     *      description: 'description of why item was tapped',
                     *      type: type: 'person' || 'place' || 'thing',
                     *      isFbEnabled: boolean
                     *  };
                     *
                     * N.B. `item` and `location` are mutually exclusive
                     */

                    var commentsObj = {};
                    self.comments.forEach(function (el, idx) {
                        commentsObj['ctx_comment_' + (idx + 1)] = el;
                    });

                    UserService[data.selectedState + 'Count']++;

                    AnalyticsService.recordEvent("TAP_SUBMIT", "3.4 - Why Did You Tap", angular.extend({
                        "ctx_locName": data.location ? data.location.name : "N/A",
                        "ctx_locAddress": data.location ? data.location.addr : "N/A",
                        "ctx_sentiment": data.selectedState,
                        "ctx_whyTap": data.description,
                        "ctx_shareChannel": "facebook"
                    }, commentsObj), {
                        "ctx_numReviews": self.numReviews,
                        "ctx_attachedPic": ImageUriService.currentImageUri ? 1 : 0
                    });

                    var observation = {
                        rating: data.selectedState,
                        description: data.description,
                        type: data.type,
                        ioiId: data.ioiId
                    };

                    if (data.hasOwnProperty('location')) {
                        // location-based tap
                        observation.place_id = data.location.place_id;
                    } else if (data.hasOwnProperty('item')) {
                        // non-location tap
                        observation.title = data.item;
                    } else {
                        // some sort of invalid tap
                        throw 'Invalid tap data';
                    }

                    sendObservation(observation);
                }, function (err) {
                    return console.error(err);
                });

                NativeTap.recordTapDurationHandler(function (duration) {
                    return AnalyticsService.recordTap(duration);
                });

                NativeTap.joinMobHandler(function (mobId) {
                    return ObservationService.join(mobId).then(function () {
                        return NativeTap.joinMobSuccess();
                    }).catch(function (err) {
                        return NativeTap.addItemFailure(err);
                    });
                });

                NativeTap.analyticsEventHandler(function (event) {
                    return AnalyticsService.recordEvent(event.eventType, event.screenName, event.attributes, event.metrics);
                });

                NativeTap.tapMoodHandler(function (mood) {
                    AnalyticsService.recordEvent("TAP", "3.0 - Tap", {
                        "ctx_sentiment": mood,
                        "ctx_locName": "N/A",
                        "ctx_locAddress": "N/A"
                    }, {});
                });

                NativeTap.addItemButtonTappedHandler(function (search) {
                    AnalyticsService.recordEvent("ADD", "3.3.1 - Search", {
                        "ctx_item": search
                    }, {});
                });

                NativeTap.tapSearchHandler(function (category) {
                    AnalyticsService.recordEvent("SEARCH", "3.3 - Search", {
                        "ctx_search": category
                    }, {});
                });
            })();
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('OnboardingController', OnboardingController);

    OnboardingController.$inject = ['$scope', '$window', '$ionicPlatform', '$state', 'LocationService', 'AnalyticsService'];

    function OnboardingController($scope, $window, $ionicPlatform, $state, LocationService, AnalyticsService) {
        var self = this;

        self.showLocationScreen = false;
        self.sliderDelegate = null;
        self.options = {
            prevButton: '.ft-onboarding-button-prev',
            nextButton: '.ft-onboarding-button-next'
        };

        self.next = next;
        self.activateLocationServices = activateLocationServices;
        self.close = close;

        $scope.$on('$ionicSlides.slideChangeEnd', function () {
            $scope.$digest(); // ensure that `self.sliderDelegate` properties update
        });

        activate();

        function activate() {
            AnalyticsService.screenView('Onboarding Slides');
        }

        function next() {
            AnalyticsService.screenView('Enable Location');

            self.showLocationScreen = true;
        }

        function activateLocationServices() {
            LocationService.startUp();
            $ionicPlatform.on('resume', LocationService.startUp);
            self.close();
        }

        function close() {
            localStorage.ONBOARDING_COMPLETE = true;
            $state.go('main.tap');
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('LoginController', LoginController);

    LoginController.$inject = ['$state', '$ionicLoading', '$cordovaDialogs', 'AuthService'];

    function LoginController($state, $ionicLoading, $cordovaDialogs, AuthService) {
        this.emailLogin = emailLogin;
        this.facebookLogin = facebookLogin;

        function emailLogin(input) {
            input = input || {};

            $ionicLoading.show().then(function () {
                AuthService.emailLogin(input.username, input.password).then(function () {
                    $ionicLoading.hide();
                    $state.go(localStorage.ONBOARDING_COMPLETE ? 'main.tap' : 'onboarding');
                }).catch(function (result) {
                    $ionicLoading.hide();
                    console.error(JSON.stringify(result));
                    $cordovaDialogs.alert('Please check your login information and try again.', 'Login Error', 'OK');
                });
            });
        }

        function facebookLogin() {
            $ionicLoading.show().then(function () {
                return AuthService.facebookAuth();
            }).then(function () {
                return $state.go(localStorage.ONBOARDING_COMPLETE ? 'main.tap' : 'onboarding');
            }).catch(function (err) {
                // TODO real error message
                alert(JSON.stringify(err));
            }).finally(function () {
                return $ionicLoading.hide();
            });
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('SignupController', SignupController);

    SignupController.$inject = ['$state', '$ionicLoading', 'AuthService'];

    function SignupController($state, $ionicLoading, AuthService) {
        this.emailSignup = emailSignup;
        this.facebookSignup = facebookSignup;
        this.validateLength = validateLength;
        this.validateNumber = validateNumber;
        this.validateCapital = validateCapital;
        this.validateLower = validateLower;
        this.validateSpecial = validateSpecial;
        this.validateMatch = validateMatch;
        this.validateExists = validateExists;
        this.validateAlphanum = validateAlphanum;

        function emailSignup(input, form) {
            input = input || {};

            // TODO validation

            $ionicLoading.show().then(function () {
                AuthService
                // TODO remove `name` requirement from user pool
                .emailSignup('Manual Signup User', input.email, input.username, input.password).then(function () {
                    $ionicLoading.hide();
                    $state.go('auth.signup-success', { hasFacebook: false });
                }).catch(function (err) {
                    console.error(err);
                    $ionicLoading.hide();

                    if (err.message.indexOf('Invalid email address format') > -1) {
                        // Amazon's email address requirements are stricter than angular's
                        form.email.$setValidity('email', false);
                    } else if (err.message.indexOf('User already exists') > -1) {
                        form.username.$setValidity('exists', false);
                    }
                });
            });
        }

        function facebookSignup() {
            $ionicLoading.show().then(function () {
                return AuthService.facebookAuth();
            }).then(function () {
                return $state.go('auth.signup-success', { hasFacebook: true });
            }).catch(function (err) {
                console.log(JSON.stringify(err));
                alert(JSON.stringify(err));
            }).finally(function () {
                return $ionicLoading.hide();
            });
        }

        function validateLength(value) {
            value = (value || '') + '';
            return value.length >= 8 && value.length <= 25;
        }

        function validateNumber(value) {
            return (/\d/.test(value || '')
            );
        }

        function validateCapital(value) {
            return (/[A-Z]/.test(value || '')
            );
        }

        function validateLower(value) {
            return (/[a-z]/.test(value || '')
            );
        }

        function validateSpecial(value) {
            return (/[!"#\$%&'\(\)\*\+,-\./:;<=>\?@\[\]\^_`\{\|\}~]/.test(value || '')
            );
        }

        function validateMatch(value1, value2) {
            value1 = (value1 || '') + '';
            value2 = (value2 || '') + '';
            return value1 && value2 && value1 === value2;
        }

        function validateExists() {
            return true; // this just clears out any validation errors on change
        }

        function validateAlphanum(value) {
            value = (value || '') + '';
            return value === '' || /^[a-z0-9]+$/i.test(value);
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('SignupSuccessController', SignupSuccessController);

    SignupSuccessController.$inject = ['$ionicLoading', '$stateParams', '$cordovaDialogs', '$state', 'AuthService'];

    function SignupSuccessController($ionicLoading, $stateParams, $cordovaDialogs, $state, AuthService) {
        var self = this;

        self.getLink = getLink;

        activate();

        function activate() {
            if (!$stateParams.hasFacebook) {
                $cordovaDialogs.confirm("When you connect your Facebook account you'll be able to connect with " + "your Facebook friends that are using the Tap app.", 'Connect with Facebook', ['No, Thanks', 'OK']).then(function (buttonIndex) {
                    if (buttonIndex == 1) {
                        // No, Thanks
                        $cordovaDialogs.alert('If you change your mind you can connect your' + ' Tap profile with Facebook in your Profile Settings. ', 'Connect with Facebook', 'OK');
                    } else if (buttonIndex == 2) {
                        // OK
                        $ionicLoading.show().then(function () {
                            return AuthService.facebookLink();
                        }).then(function (result) {
                            $cordovaDialogs.alert('Successfully linked your Tap profile with Facebook!', 'Connect with Facebook', 'OK');

                            console.log(result);
                        }).catch(function (err) {
                            $cordovaDialogs.alert('There was an error connecting your Tap profile with ' + 'Facebook.  You can try again later in your Profile Settings.', 'Connect with Facebook', 'OK');

                            console.log(err);
                        }).finally(function () {
                            return $ionicLoading.hide();
                        });
                    }
                });
            }
        }

        function getLink() {
            return $state.href(localStorage.ONBOARDING_COMPLETE ? 'main.tap' : 'onboarding');
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('FeedController', FeedController);

    FeedController.$inject = ['$stateParams', '$scope', '$ionicLoading', 'ObservationService', 'ObservationModalService', 'UserService', 'PushNotificationService', 'AnalyticsService'];

    function FeedController($stateParams, $scope, $ionicLoading, ObservationService, ObservationModalService, UserService, PushNotificationService, AnalyticsService) {
        var self = this;

        self.feedItems = [];
        self.loading = true;
        self.currentFeed = 'mine';
        self.fetchFeedsMine = fetchFeedsMine;
        self.fetchFeedsFriends = fetchFeedsFriends;
        self.showItem = showItem;

        activate();

        function activate() {
            self.fetchFeedsMine();

            if ($stateParams.tapCreated && !PushNotificationService.hasSeenNudge()) {
                PushNotificationService.promptToEnable();
            }
        }

        function fetchFeedsMine() {
            AnalyticsService.screenView('My Feed');
            AnalyticsService.recordEvent("FEED", "9 - Feed", {}, {
                "ctx_Mine": 1,
                "ctx_Friends": 0
            });

            self.feedItems = [];
            self.loading = true;
            self.currentFeed = 'mine';

            $ionicLoading.show().then(function () {
                return ObservationService.observationFeed();
            }).then(function (data) {
                return self.feedItems = data.data['Items'];
            }).catch(function (err) {
                return console.error(JSON.stringify(err));
            }).finally(function () {
                self.loading = false;
                $ionicLoading.hide();
            });
        }

        function fetchFeedsFriends() {
            AnalyticsService.screenView('Friends Feed');
            AnalyticsService.recordEvent("FEED", "9 - Feed", {}, {
                "ctx_Mine": 0,
                "ctx_Friends": 1
            });

            self.feedItems = [];
            self.loading = true;
            self.currentFeed = 'friends';

            $ionicLoading.show().then(function () {
                return ObservationService.friendFeed(UserService.friends);
            }).then(function (feed) {
                return self.feedItems = feed.data;
            }).catch(function (err) {
                return console.error(JSON.stringify(err));
            }).finally(function () {
                self.loading = false;
                $ionicLoading.hide();
            });
        }

        function showItem(item) {
            $ionicLoading.show().then(function () {
                return ObservationService.observationDetails(item.observationId);
            }).then(function (data) {
                ObservationModalService.showModal(data.data['Items'][0]);
            }).catch(function (err) {
                return console.error(err);
            }).finally(function () {
                return $ionicLoading.hide();
            });
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('MobsController', MobsController);

    MobsController.$inject = ['$state', '$timeout', '$ionicLoading', '$ionicScrollDelegate', 'lodash', 'ObservationService', 'LocationService', 'ObservationModalService', 'TapDetailsModalService', 'AnalyticsService'];

    function MobsController($state, $timeout, $ionicLoading, $ionicScrollDelegate, lodash, ObservationService, LocationService, ObservationModalService, TapDetailsModalService, AnalyticsService) {
        var self = this;
        var resultsObj = { people: {}, places: {}, things: {} };

        var items = { people: null, places: null, things: null };
        var searchStringCache = { people: '', places: '', things: '' };

        var isJoiningMob = false;

        self.categories = ['people', 'places', 'things'];
        self.selectedCategory = null;
        self.displayItems = null;
        self.searchString = null;
        self.lastSearchedString = null;
        self.loaded = false;

        self.getSelectedCategoryClass = getSelectedCategoryClass;
        self.selectCategory = selectCategory;
        self.searchMobs = searchMobs;
        self.showMobDetails = showMobDetails;
        self.joinMob = joinMob;

        activate();

        function activate() {
            AnalyticsService.screenView('Mobs');

            if (ObservationService.placeToView) {
                (function () {
                    var place = ObservationService.placeToView;
                    ObservationService.placeToView = null;

                    items.places = []; // `selectCategory` will not load the default list if this already exists
                    selectCategory('places');
                    self.searchString = place.title;

                    $ionicLoading.show().then(function () {
                        return retrievePlaceMobs(place);
                    }).finally(function () {
                        self.loaded = true;
                        $ionicLoading.hide();
                    });
                })();
            } else {
                selectCategory($state.$current.selected || 'places');
            }
        }

        function getSelectedCategoryClass() {
            var index = self.categories.indexOf(self.selectedCategory);

            return index !== -1 ? 'ft-nav-selected-' + (index + 1) : false;
        }

        function selectCategory(category) {
            // Will add results object if it exists, otherwise will just send ctx_search
            AnalyticsService.recordEvent("MOBS", "4.5 - Mob", angular.extend({
                "ctx_search": category
            }, resultsObj[category]), {});

            if (self.selectedCategory !== category) {
                if (searchStringCache.hasOwnProperty(self.selectedCategory)) {
                    searchStringCache[self.selectedCategory] = self.searchString;
                }

                self.selectedCategory = category;
                self.displayItems = items[category];
                self.searchString = searchStringCache[category];
                $state.$current.selected = category;
                $ionicScrollDelegate.$getByHandle('list').scrollTop(false);

                $timeout(function () {
                    return self.lastSearchedString = self.searchString;
                }); // wrapped in $timeout to prevent flicker

                if (!self.displayItems) {
                    $ionicLoading.show().then(function () {
                        return retrieveDefaultMobs(category);
                    }).finally(function () {
                        self.loaded = true;
                        $ionicLoading.hide();
                    });
                }
            }
        }

        function searchMobs(category, searchString) {
            var type = getTypeFromCategory(category);

            searchString = (searchString || '') + ''; // ensure stringiness

            if (searchString.length < 3) {
                return retrieveDefaultMobs(category);
            } else {
                return ObservationService.searchMobs(type, searchString).then(function (results) {
                    setDisplayItems(category, results, searchString);

                    // Clear results object by category
                    resultsObj[category] = {};
                    results.forEach(function (el, idx) {
                        resultsObj[category]["ctx_score_" + (idx + 1)] = el.upvoteCount;
                        resultsObj[category]["ctx_name_" + (idx + 1)] = el.title;
                        resultsObj[category]["ctx_review_text_" + (idx + 1)] = el.description;
                        resultsObj[category]["ctx_distance_" + (idx + 1)] = el.distance || "N/A";
                    });

                    AnalyticsService.recordEvent("MOBS", "4.5 - Mob", angular.extend({
                        "ctx_search": category
                    }, resultsObj[category]), {});
                }).catch(function (err) {
                    return console.error(err);
                });
            }
        }

        function showMobDetails(mob) {
            TapDetailsModalService.showMobDetails(mob, self.selectedCategory);
        }

        function joinMob(mob) {
            if (!isJoiningMob && !mob.isMobMember) {
                isJoiningMob = true;

                ObservationService.join(mob).finally(function () {
                    return isJoiningMob = false;
                });
            }
        }

        function getTypeFromCategory(category) {
            if (category === 'people') {
                return 'person';
            } else if (category === 'places') {
                return 'place';
            } else if (category === 'things') {
                return 'thing';
            }

            return null;
        }

        function setDisplayItems(category, displayItems, searchString) {
            if (searchString) {
                self.lastSearchedString = searchString;
            }

            return $timeout(function () {
                // wrapped in $timeout to prevent flicker
                if (!items[category]) {
                    items[category] = [];
                }

                angular.copy(displayItems, items[category]);

                if (!self.displayItems) {
                    self.displayItems = items[category];
                }

                return self.displayItems;
            });
        }

        function retrieveDefaultMobs(category) {
            var type = getTypeFromCategory(category);
            var coords = LocationService.hasLocation ? LocationService.lastKnownLocation.coords : null;

            return ObservationService.getMobs(type, coords).then(function (results) {
                return setDisplayItems(category, results);
            }).catch(function (err) {
                return console.error(err);
            });
        }

        function retrievePlaceMobs(place) {
            return ObservationService.getMobsForLocation(place.placeId).then(function (items) {
                return items.filter(function (item) {
                    return item.upvoteCount;
                });
            }) // only want movements with upvotes
            .then(function (results) {
                return setDisplayItems('places', results, place.title);
            }).catch(function (err) {
                return console.error(err);
            });
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('NearbyController', NearbyController);

    NearbyController.$inject = ['$state', '$timeout', '$scope', '$cordovaDialogs', '$ionicModal', 'lodash', 'IOIService', 'LocationService', 'TapDetailsModalService', 'AnalyticsService'];

    function NearbyController($state, $timeout, $scope, $cordovaDialogs, $ionicModal, lodash, IOIService, LocationService, TapDetailsModalService, AnalyticsService) {
        var self = this;

        self.locationResults = [];
        self.locationSearchString = '';
        self.filterLocation = ''; // location search string
        self.filterCategories = []; // categories to filter; empty returns all categories
        self.filterPlace = null; // location filter place; use current location if falsy
        self.filterRatings = null; // which ratings to show; will be set in filter modal
        self.filterMobsOnly = false;
        self.loaded = false;
        self.items = null;

        self.loadLocations = loadLocations;
        self.openFilter = openFilter;
        self.locationSearch = locationSearch;
        self.selectLocation = selectLocation;
        self.viewTaps = viewTaps;
        self.getActiveCategories = getActiveCategories;

        activate();

        function activate() {
            loadLocations();
        }

        function loadLocations(coords, categories) {
            categories = categories || [];

            self.items = null;
            self.loaded = false;
            $scope.$broadcast('nearbyLoadStart');

            IOIService.getNearby(coords, categories).then(function (response) {
                self.items = response.items;
                var numMOBs = self.items.reduce(function (sum, el) {
                    return sum += el.isMob;
                }, 0);
                $scope.$broadcast('nearbyLoadSuccess', response.items, response.boundingBox);

                var filterCategories = lodash.compact(response.categories).sort().map(function (label) {
                    return {
                        label: label,
                        active: categories.indexOf(label) !== -1 // active if category was previously selected
                    };
                });
                angular.copy(filterCategories, self.filterCategories); // preserve object reference

                var searchObj = {};
                response.items.forEach(function (el, idx) {
                    searchObj['ctx_score_' + (idx + 1)] = el.rating;
                    searchObj['ctx_name_' + (idx + 1)] = el.title;
                    searchObj['ctx_distance_' + (idx + 1)] = el.distance;
                });

                AnalyticsService.recordEvent("NEARBY", "4.1 - Nearby", searchObj, {
                    "ctx_Map": $state.current.name.indexOf('map') !== -1 ? 1 : 0,
                    "ctx_MOBs": numMOBs ? 1 : 0,
                    "ctx_numMOBs": numMOBs
                });
            }).catch(function (err) {
                $cordovaDialogs.alert('Unable to load location data.', 'Location Error', 'OK');
                $scope.$broadcast('nearbyLoadError');
            }).finally(function () {
                return self.loaded = true;
            });
        }

        function openFilter() {
            var scope = $scope.$new();
            var oldCategories = self.getActiveCategories();

            scope.closeModal = function () {
                return scope.modal && scope.modal.hide();
            };

            scope.$on('$destroy', function () {
                scope && scope.modal && scope.modal.remove();
            });

            scope.$on('modal.hidden', function () {
                var categories = self.getActiveCategories();

                if (!angular.equals(categories, oldCategories)) {
                    loadLocations(self.filterPlace ? self.filterPlace.coords : null, categories);
                }

                self.filterMobsOnly = scope.options.mobsOnly;
                self.filterRatings = scope.options.ratings;

                var screenName = $state.current.name.indexOf('map') !== -1 ? 'Nearby Map' : 'Nearby List';

                AnalyticsService.recordEvent('FILTER_DISMISS', screenName, {
                    ctx_filterCategories: categories.join(',') || 'all'
                }, {
                    ctx_mobsOnly: scope.options.mobsOnly ? 1 : 0,
                    ctx_myNetworkOnly: 0 // TODO use actual value when this is implemented
                });
            });

            scope.options = {
                mobsOnly: self.filterMobsOnly,
                ratings: self.filterRatings
            };

            return $ionicModal.fromTemplateUrl('app/routes/main/nearby/filter-modal/filter-modal.html', {
                scope: scope,
                animation: 'slide-in-right'
            }).then(function (modal) {
                scope.modal = modal;
                scope.modal.show();

                $scope.$broadcast('nearbyFilterOpened');
            });
        }

        function locationSearch(searchString) {
            LocationService.locationSearch(searchString).then(function (results) {
                self.locationResults = results;

                var namesObj = {};
                results.forEach(function (el, idx) {
                    namesObj['ctx_name_' + (idx + 1)] = el.description;
                });

                AnalyticsService.recordEvent("NEARBY", "4.1 - Nearby", namesObj, {
                    "ctx_Map": $state.current.name.indexOf('map') !== -1 ? 1 : 0
                });
            }).catch(function (err) {
                self.locationResults = [];
                console.error(err);
            });
        }

        function selectLocation(placeId) {
            LocationService.getPlaceDetails(placeId).then(function (place) {
                self.locationResults = [];
                self.locationSearchString = place.name;
                self.filterPlace = place;
                self.filterPlace.coords = {
                    latitude: place.geometry.location.lat(),
                    longitude: place.geometry.location.lng()
                };

                $scope.$broadcast('nearbyLocationChange', self.filterPlace);
                loadLocations(self.filterPlace.coords);
            }).catch(function (err) {
                $cordovaDialogs.alert('Unable to load location data.', 'Location Error', 'OK');
            });
        }

        function viewTaps(place) {
            TapDetailsModalService.showTapDetails(place.placeId);
            AnalyticsService.recordEvent("VIEW_LOCATION", "4.3 - Nearby", {
                "ctx_locName": place.title,
                "ctx_locAddress": place.address,
                "ctx_filterCategories": getActiveCategories().join(',') || 'all'
            }, {});
        }

        function getActiveCategories() {
            return self.filterCategories.filter(function (category) {
                return category.active;
            }).map(function (category) {
                return category.label;
            });
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('ProfileController', ProfileController);

    ProfileController.$inject = ['$scope', '$timeout', '$ionicActionSheet', 'AuthService', 'LocationService', 'UserService', 'ProfilePictureService'];

    function ProfileController($scope, $timeout, $ionicActionSheet, AuthService, LocationService, UserService, ProfilePictureService) {
        var self = this;

        self.hasFacebook = AuthService.isUsingFacebook();
        self.photoLoaded = false;

        self.user = {
            photoLink: UserService.photoLink,
            name: UserService.name || UserService.username,
            location: UserService.location,

            stats: [{ name: 'love', number: null }, { name: 'ok', number: null }, { name: 'hate', number: null }]
        };

        self.choosePhoto = choosePhoto;

        activate();

        function activate() {

            if (!self.user.location && LocationService.lastKnownLocation) {
                LocationService.getPlaceName({
                    lat: LocationService.lastKnownLocation.coords.latitude,
                    lng: LocationService.lastKnownLocation.coords.longitude
                }).then(function (placeName) {
                    return self.user.location = placeName;
                });
            }

            UserService.registerUser(UserService.socialId, UserService.email, ProfilePictureService.getFacebookProfilePictureUrl(), UserService.username).then(function (response) {
                setPhoto(response.data.photoLink || 'app/img/fallback-profile-image.png');

                self.user.stats[0].number = response.data.loveCount || 0;
                self.user.stats[1].number = response.data.okCount || 0;
                self.user.stats[2].number = response.data.hateCount || 0;
            });
        }

        function choosePhoto() {
            var buttons = [{ text: (ionic.Platform.isAndroid() ? '<i class="icon ion-android-camera"></i> ' : '') + 'Take a Photo' }, { text: (ionic.Platform.isAndroid() ? '<i class="icon ion-android-person"></i> ' : '') + 'Use Facebook Photo' }];

            if (!self.hasFacebook) {
                buttons.pop();
            }

            var hideSheet = $ionicActionSheet.show({
                titleText: 'Choose a Photo',
                buttons: buttons,
                cancelText: '<strong>Cancel</strong>',
                cancel: function cancel() {},
                buttonClicked: function buttonClicked(index) {
                    if (index === 0) {
                        takePhoto();
                    } else if (index === 1) {
                        facebookPhoto();
                    }

                    hideSheet();
                }
            });
        }

        function takePhoto() {
            ProfilePictureService.takeProfilePicture().then(function (blob) {
                var reader = new FileReader();

                reader.onload = function () {
                    return $scope.$apply(setPhoto(reader.result));
                };
                reader.readAsDataURL(blob);

                return ProfilePictureService.uploadProfilePicture(blob);
            }).catch(function (err) {
                return console.error(err);
            });
        }

        function facebookPhoto() {
            ProfilePictureService.useFacebookProfilePicture().then(function (photoLink) {
                return setPhoto(photoLink);
            }).catch(function (err) {
                return console.error(err);
            });
        }

        function setPhoto(photoLink) {
            if (self.user.photoLink && self.user.photoLink !== photoLink) {
                self.photoLoaded = false;
                self.user.photoLink = '';

                $timeout(function () {
                    return self.user.photoLink = photoLink;
                }, 300); // wait for picture fade out animation to complete
            } else {
                self.user.photoLink = photoLink;
            }
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('TapController', TapController);

    TapController.$inject = ['AnalyticsService'];

    function TapController(AnalyticsService) {
        var self = this;

        activate();

        function activate() {
            AnalyticsService.screenView('Main Tap');
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('FilterModalController', FilterModalController);

    FilterModalController.$inject = ['$scope', 'AnalyticsService'];

    function FilterModalController($scope, AnalyticsService) {
        var self = this;

        self.allActive = checkAllActive();
        self.ratings = ['love', 'ok', 'hate'];

        // we want this object to be distinct from nearbyCtrl.filterRatings so that the new filter doesn't take effect
        // until the modal is closed
        $scope.options.ratings = $scope.options.ratings ? angular.copy($scope.options.ratings) : self.ratings.reduce(function (status, rating) {
            status[rating] = true; // start with all active
            return status;
        }, {});

        var ratingStatus = $scope.options.ratings;

        self.toggle = toggle;
        self.toggleAll = toggleAll;
        self.toggleRating = toggleRating;
        self.isRatingActive = isRatingActive;

        activate();

        function activate() {
            AnalyticsService.screenView('Nearby Filter');
        }

        function toggle(category) {
            category.active = !category.active;

            self.allActive = checkAllActive();
        }

        function toggleAll() {
            if (!self.allActive) {
                self.allActive = true;
                $scope.nearbyCtrl.filterCategories.forEach(function (category) {
                    return category.active = false;
                });
            } else {
                // if `all` is active, then no other categories are selected, so do nothing
            }
        }

        function checkAllActive() {
            return $scope.nearbyCtrl.filterCategories.reduce(function (result, category) {
                return category.active ? false : result;
            }, true);
        }

        function toggleRating(rating) {
            ratingStatus[rating] = !ratingStatus[rating];
        }

        function isRatingActive(rating) {
            return ratingStatus[rating];
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('NearbyListController', NearbyListController);

    NearbyListController.$inject = ['AnalyticsService'];

    function NearbyListController(AnalyticsService) {
        var self = this;

        activate();

        function activate() {
            AnalyticsService.screenView('Nearby List');
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('NearbyMapController', NearbyMapController);

    NearbyMapController.$inject = ['$state', '$q', '$templateRequest', '$scope', '$compile', '$timeout', '$ionicLoading', 'moment', 'LocationService', 'IOIService', 'ObservationService', 'AnalyticsService'];

    function NearbyMapController($state, $q, $templateRequest, $scope, $compile, $timeout, $ionicLoading, moment, LocationService, IOIService, ObservationService, AnalyticsService) {
        var self = this;

        var screenName = 'Nearby Map';
        var DEFAULT_ZOOM = 18;
        var MapIcon = L.DivIcon.extend({
            options: {
                className: 'ft-map-icon',
                iconSize: [30, 31],
                iconAnchor: [15, 15.5]
            }
        });
        var loveIcon = new MapIcon({ html: '<img src="app/img/map-pin_love.png">' });
        var okIcon = new MapIcon({ html: '<img src="app/img/map-pin_ok.png">' });
        var hateIcon = new MapIcon({ html: '<img src="app/img/map-pin_hate.png">' });
        var noTapsIcon = new MapIcon({ html: '<img src="app/img/map-pin_no_mobs.png">' });

        var map = void 0;
        var locationMarkers = [];
        var currentLocationMarker = void 0;
        var currentPosition = void 0;
        var boundingBox = null; // the bounding box of the current result set

        self.hasLocation = LocationService.hasLocation;
        self.canRecenter = false;

        self.viewMobs = viewMobs;
        self.centerMap = centerMap;

        $scope.$on('nearbyLoadStart', function (event) {});

        $scope.$on('nearbyLoadSuccess', function (event, items, box) {
            clearMarkers();
            addMarkers(items);

            boundingBox = new L.LatLngBounds( // `box` looks like [minlat, minlon, maxlat, maxlon]
            new L.LatLng(box[0], box[1]), new L.LatLng(box[2], box[3]));
        });

        $scope.$on('nearbyLocationChange', function (event, place) {
            map.setView(new L.LatLng(place.coords.latitude, place.coords.longitude), DEFAULT_ZOOM);
        });

        $scope.$on('nearbyFilterOpened', function (event) {
            return map.closePopup();
        }); // close all popups on filter open to prevent items
        // removed by filtering from having popups retained
        activate();

        function activate() {
            AnalyticsService.screenView(screenName);

            if (self.hasLocation) {
                (function () {
                    var coords = $scope.nearbyCtrl.filterPlace ? $scope.nearbyCtrl.filterPlace.coords : LocationService.lastKnownLocation.coords;

                    $timeout(function () {
                        // this section must be wrapped in a timeout for the tile layer to load correctly
                        currentPosition = L.latLng(coords.latitude, coords.longitude);
                        map = L.map('ft-nearby-map').setView(currentPosition, DEFAULT_ZOOM);

                        L.tileLayer('http://mt{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
                            subdomains: [0, 1, 2, 3],
                            attribution: '',
                            attributionControl: false,
                            maxZoom: 22,
                            maxNativeZoom: 20,
                            minZoom: 12
                        }).addTo(map);

                        currentLocationMarker = L.marker(currentPosition, {
                            clickable: false,
                            zIndexOffset: 1000
                        });
                        currentLocationMarker.addTo(map);
                    }, 0).then(function () {
                        if ($scope.nearbyCtrl.items) {
                            addMarkers($scope.nearbyCtrl.items);
                        }

                        map.on('moveend', function () {
                            return $timeout(function () {
                                var mapBox = map.getBounds();
                                var mapCenter = map.getCenter();
                                var mapLocations = locationMarkers.filter(function (marker) {
                                    return mapBox.contains(marker._latlng) && marker.title;
                                }).map(function (marker) {
                                    return marker.title;
                                });

                                AnalyticsService.recordEvent('MAP_PANNING', screenName, {
                                    ctx_locations: mapLocations.join(', ')
                                }, {
                                    ctx_numLocs: mapLocations.length,
                                    ctx_centerMapLat: mapCenter.lat,
                                    ctx_centerMapLong: mapCenter.lng
                                });

                                if (boundingBox && !boundingBox.contains(mapBox)) {
                                    $scope.nearbyCtrl.loadLocations({ latitude: mapCenter.lat, longitude: mapCenter.lng }, $scope.nearbyCtrl.getActiveCategories());
                                }

                                self.canRecenter = !map.getBounds().contains(currentPosition);
                            });
                        });
                    });
                })();
            }
        }

        function clearMarkers() {
            var _loop = function _loop() {
                var marker = locationMarkers.pop();
                angular.element(marker._icon).removeClass('ft-visible');

                $timeout(function () {
                    map.removeLayer(marker);
                }, 300);
            };

            while (locationMarkers.length) {
                _loop();
            }
        }

        function addMarkers(items) {
            $q.all(items.map(function (item) {
                var icon = void 0;

                if ('love' === item.rating) {
                    icon = loveIcon;
                } else if ('ok' === item.rating) {
                    icon = okIcon;
                } else if ('hate' === item.rating) {
                    icon = hateIcon;
                }

                return addMarker(item, icon);
            })).then(function () {
                var place = $scope.nearbyCtrl.filterPlace;

                if (place && place.types.indexOf('establishment') !== -1) {
                    var _marker = getMarkerByPlaceId(place.place_id);
                    var getCurrentMarker = _marker ? $q.resolve(_marker) : addMarker({
                        placeId: place.place_id,
                        coords: place.coords,
                        title: place.name,
                        address: place.formatted_address,
                        phone: place.formatted_phone_number,
                        closingTime: place.opening_hours ? LocationService.getClosingTimes(place.opening_hours)[moment().day()] : null,
                        isMob: false
                    }, noTapsIcon);

                    // if our dot overlaps others, we'll zoom in a little bit more
                    getCurrentMarker.then(function (marker) {
                        var point = map.latLngToLayerPoint(marker._latlng);
                        var minDistance = Math.min.apply(null, locationMarkers.map(function (otherMarker) {
                            return otherMarker !== marker ? map.latLngToLayerPoint(otherMarker._latlng).distanceTo(point) : 99999;
                        }));

                        if (minDistance < 30) {
                            map.setZoom(DEFAULT_ZOOM + (minDistance < 7 ? 2 : 1));
                        }
                    });
                }
            });
        }

        function addMarker(item, icon) {
            var marker = L.marker([item.coords.latitude, item.coords.longitude], { icon: icon });
            marker.placeId = item.placeId;
            marker.title = item.title;

            return createPopup(item).then(function (popup) {
                marker.bindPopup(popup);
                marker.addTo(map);

                if (item.isMob) {
                    angular.element(marker._icon).addClass('ft-map-icon-mob');
                }

                if (item.rating) {
                    angular.element(marker._icon).addClass('ft-map-icon-' + item.rating);
                }

                locationMarkers.push(marker);

                return $timeout(function () {
                    angular.element(marker._icon).addClass('ft-visible');

                    return marker;
                });
            });
        }

        function createPopup(place) {
            return $templateRequest('app/routes/main/nearby/nearby-map/nearby-popup/nearby-popup.html').then(function (template) {
                var scope = $scope.$new();
                scope.place = place;
                return $compile(angular.element(template))(scope)[0];
            });
        }

        function getMarkerByPlaceId(placeId) {
            return locationMarkers.reduce(function (foundMarker, marker) {
                return foundMarker || (marker.placeId === placeId ? marker : null);
            }, null);
        }

        function viewMobs(place) {
            ObservationService.placeToView = place;
            $state.go('main.mobs');
        }

        function centerMap() {
            if (LocationService.hasLocation) {
                var coords = LocationService.lastKnownLocation.coords;
                currentPosition = L.latLng(coords.latitude, coords.longitude);
            }

            currentLocationMarker.setLatLng(currentPosition);
            map.setView(currentPosition, DEFAULT_ZOOM);
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('MyMobsController', MyMobsController);

    MyMobsController.$inject = ['ObservationService', 'AnalyticsService', 'TapDetailsModalService'];

    function MyMobsController(ObservationService, AnalyticsService, TapDetailsModalService) {
        var self = this;

        self.items = [];
        self.loaded = false;

        self.showMobDetails = showMobDetails;

        activate();

        function activate() {
            AnalyticsService.screenView('My Mobs');
            AnalyticsService.recordEvent("PROFILE", "5 - User Profile", {}, {
                "ctx_MOBs": 1,
                "ctx_Settings": 0
            });

            ObservationService.upvotedObservationFeed().then(function (response) {
                return self.items = response.data;
            }).catch(function (err) {
                return console.error(err);
            }).finally(function () {
                return self.loaded = true;
            });
        }

        function showMobDetails(mob) {
            TapDetailsModalService.showMobDetails(mob, null);
        }
    }
})();
'use strict';

(function () {
    'use strict';

    angular.module('ftap').controller('SettingsController', SettingsController);

    SettingsController.$inject = ['$scope', '$state', '$window', '$timeout', '$ionicModal', '$cordovaDialogs', '$ionicLoading', 'FTAP_CONFIG', 'AuthService', 'SharingService', 'AnalyticsService'];

    function SettingsController($scope, $state, $window, $timeout, $ionicModal, $cordovaDialogs, $ionicLoading, FTAP_CONFIG, AuthService, SharingService, AnalyticsService) {
        var self = this;

        self.sharing = SharingService;
        self.showDebugInfo = FTAP_CONFIG.SHOW_DEBUG_INFO;
        self.versionNumber = FTAP_CONFIG.VERSION_NUMBER;

        self.connectToFacebook = connectToFacebook;
        self.disconnectFromFacebook = disconnectFromFacebook;
        self.logOut = logOut;
        self.displayTermsAndConditions = displayTermsAndConditions;

        $scope.closeModal = function () {
            return self.modal && self.modal.hide();
        };

        activate();

        function activate() {
            AnalyticsService.screenView('Settings');
            AnalyticsService.recordEvent("PROFILE", "5 - User Profile", {}, {
                "ctx_MOBs": 0,
                "ctx_Settings": 1
            });
        }

        function connectToFacebook() {
            $ionicLoading.show().then(function () {
                return AuthService.facebookLink();
            }).then(function () {
                return $state.go($state.current, {}, { reload: true });
            }).catch(function (err) {
                $cordovaDialogs.alert('There was an error connecting your Tap profile with Facebook.', 'Connect with Facebook', 'OK');
                console.error(JSON.stringify(err));
            }).finally(function () {
                return $ionicLoading.hide();
            });
        }

        function disconnectFromFacebook() {
            $ionicLoading.show().then(function () {
                return AuthService.facebookUnlink();
            }).then(function () {
                return $state.go($state.current, {}, { reload: true });
            }).catch(function (err) {
                $cordovaDialogs.alert('There was an error disconnecting your Tap profile from Facebook.', 'Disconnect from Facebook', 'OK');

                console.error(JSON.stringify(err));
            }).finally(function () {
                return $ionicLoading.hide();
            });
        }

        // Open terms and conditions popup
        function displayTermsAndConditions() {
            $ionicModal.fromTemplateUrl('app/routes/main/profile/settings/terms-and-conditions-modal.html', {
                backdropClickToClose: false,
                scope: $scope
            }).then(function (modal) {
                self.modal = modal;
                self.modal.show();
            });
        }

        function logOut() {
            AuthService.logOut().then(function () {
                if (angular.isDefined($window.navigator) && angular.isDefined($window.navigator.splashscreen)) {
                    $window.navigator.splashscreen.show();
                }

                return $state.go('auth.signup', { reload: true });
            });
        }
    }
})();
//# sourceMappingURL=ftap.min.js.map
